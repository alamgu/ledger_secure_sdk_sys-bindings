/* automatically generated by rust-bindgen 0.65.1 */

pub const IO_HID_EP_LENGTH: u32 = 64;
pub const USB_SEGMENT_SIZE: u32 = 64;
pub const IO_USB_MAX_ENDPOINTS: u32 = 6;
pub const IO_SEPROXYHAL_BUFFER_SIZE_B: u32 = 128;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"4.3.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __NEWLIB_H__: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _LITE_EXIT: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _NANO_FORMATTED_IO: u32 = 1;
pub const _NANO_MALLOC: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const CX_OK: u32 = 0;
pub const CX_CARRY: u32 = 4294967073;
pub const CX_LOCKED: u32 = 4294967169;
pub const CX_UNLOCKED: u32 = 4294967170;
pub const CX_NOT_LOCKED: u32 = 4294967171;
pub const CX_NOT_UNLOCKED: u32 = 4294967172;
pub const CX_INTERNAL_ERROR: u32 = 4294967173;
pub const CX_INVALID_PARAMETER_SIZE: u32 = 4294967174;
pub const CX_INVALID_PARAMETER_VALUE: u32 = 4294967175;
pub const CX_INVALID_PARAMETER: u32 = 4294967176;
pub const CX_NOT_INVERTIBLE: u32 = 4294967177;
pub const CX_OVERFLOW: u32 = 4294967178;
pub const CX_MEMORY_FULL: u32 = 4294967179;
pub const CX_NO_RESIDUE: u32 = 4294967180;
pub const CX_EC_INFINITE_POINT: u32 = 4294967105;
pub const CX_EC_INVALID_POINT: u32 = 4294967202;
pub const CX_EC_INVALID_CURVE: u32 = 4294967203;
pub const CX_AES_BLOCK_SIZE: u32 = 16;
pub const CX_AES_128_KEY_LEN: u32 = 16;
pub const CX_DES_BLOCK_SIZE: u32 = 8;
pub const CX_BN_WORD_ALIGNEMENT: u32 = 16;
pub const CX_BN_FLAG_UNSET: u32 = 128;
pub const CX_MAX_DOMAIN_LENGTH: u32 = 66;
pub const CX_ECCINFO_PARITY_ODD: u32 = 1;
pub const CX_ECCINFO_xGTn: u32 = 2;
pub const CX_LAST: u32 = 1;
pub const CX_SIG_MODE: u32 = 2;
pub const CX_MASK_SIGCRYPT: u32 = 6;
pub const CX_ENCRYPT: u32 = 4;
pub const CX_DECRYPT: u32 = 0;
pub const CX_SIGN: u32 = 6;
pub const CX_VERIFY: u32 = 2;
pub const CX_MASK_PAD: u32 = 56;
pub const CX_PAD_NONE: u32 = 0;
pub const CX_PAD_ISO9797M1: u32 = 8;
pub const CX_PAD_ISO9797M2: u32 = 16;
pub const CX_PAD_PKCS1_1o5: u32 = 24;
pub const CX_PAD_PKCS1_PSS: u32 = 32;
pub const CX_PAD_PKCS1_OAEP: u32 = 40;
pub const CX_MASK_CHAIN: u32 = 448;
pub const CX_CHAIN_ECB: u32 = 0;
pub const CX_CHAIN_CBC: u32 = 64;
pub const CX_CHAIN_CTR: u32 = 128;
pub const CX_CHAIN_CFB: u32 = 192;
pub const CX_CHAIN_OFB: u32 = 256;
pub const CX_MASK_ECC_VARIANT: u32 = 448;
pub const CX_NO_CANONICAL: u32 = 64;
pub const CX_MASK_RND: u32 = 3584;
pub const CX_RND_PRNG: u32 = 512;
pub const CX_RND_TRNG: u32 = 1024;
pub const CX_RND_RFC6979: u32 = 1536;
pub const CX_RND_PROVIDED: u32 = 2048;
pub const CX_MASK_EC: u32 = 28672;
pub const CX_ECSCHNORR_BIP0340: u32 = 0;
pub const CX_ECDH_POINT: u32 = 4096;
pub const CX_ECDH_X: u32 = 8192;
pub const CX_ECSCHNORR_ISO14888_XY: u32 = 12288;
pub const CX_ECSCHNORR_ISO14888_X: u32 = 16384;
pub const CX_ECSCHNORR_BSI03111: u32 = 20480;
pub const CX_ECSCHNORR_LIBSECP: u32 = 24576;
pub const CX_ECSCHNORR_Z: u32 = 28672;
pub const CX_NO_REINIT: u32 = 32768;
pub const APPLICATION_FLAG_MAIN: u32 = 1;
pub const APPLICATION_FLAG_BOLOS_UPGRADE: u32 = 2;
pub const APPLICATION_FLAG_SIGNED: u32 = 4;
pub const APPLICATION_FLAG_BOLOS_UX: u32 = 8;
pub const APPLICATION_FLAG_DERIVE_MASTER: u32 = 16;
pub const APPLICATION_FLAG_SHARED_NVRAM: u32 = 32;
pub const APPLICATION_FLAG_GLOBAL_PIN: u32 = 64;
pub const APPLICATION_FLAG_DEBUG: u32 = 128;
pub const APPLICATION_FLAG_AUTOBOOT: u32 = 256;
pub const APPLICATION_FLAG_BOLOS_SETTINGS: u32 = 512;
pub const APPLICATION_FLAG_CUSTOM_CA: u32 = 1024;
pub const APPLICATION_FLAG_LIBRARY: u32 = 2048;
pub const APPLICATION_FLAG_NO_RUN: u32 = 4096;
pub const APPLICATION_FLAG_ISSUER: u32 = 16384;
pub const APPLICATION_FLAG_ENABLED: u32 = 32768;
pub const APPLICATION_FLAG_BACKGROUND_IMG: u32 = 65536;
pub const APPLICATION_FLAG_AEM_PIN: u32 = 8;
pub const APPLICATION_FLAGS_MASK: u32 = 65535;
pub const APPLICATION_FLAG_NEG_MASK: u32 = 4294901760;
pub const APPLICATION_FLAGS_SHIFT: u32 = 16;
pub const TARGET_ID: u32 = 855638020;
pub const ERR_IOL_RANGE: u32 = 4096;
pub const ERR_TSK_RANGE: u32 = 8192;
pub const ERR_CRY_RANGE: u32 = 12288;
pub const ERR_PAR_RANGE: u32 = 16384;
pub const ERR_SEC_RANGE: u32 = 20480;
pub const ERR_APD_RANGE: u32 = 24576;
pub const ERR_MUI_RANGE: u32 = 40960;
pub const ERR_APP_RANGE_01: u32 = 45056;
pub const ERR_APP_RANGE_02: u32 = 49152;
pub const ERR_APP_RANGE_03: u32 = 53248;
pub const ERR_APP_RANGE_04: u32 = 57344;
pub const ERR_GEN_SUB_01: u32 = 256;
pub const ERR_GEN_SUB_02: u32 = 512;
pub const ERR_GEN_SUB_03: u32 = 768;
pub const ERR_GEN_SUB_04: u32 = 1024;
pub const ERR_GEN_SUB_05: u32 = 1280;
pub const ERR_GEN_SUB_06: u32 = 1536;
pub const ERR_GEN_SUB_07: u32 = 1792;
pub const ERR_GEN_SUB_08: u32 = 2048;
pub const ERR_GEN_SUB_09: u32 = 2304;
pub const ERR_GEN_SUB_0D: u32 = 3328;
pub const ERR_GEN_SUB_0E: u32 = 3584;
pub const ERR_IOL_OFW: u32 = 4352;
pub const ERR_IOL_HDR: u32 = 4608;
pub const ERR_IOL_STA: u32 = 4864;
pub const ERR_IOL_RST: u32 = 5120;
pub const ERR_IOL_BLE: u32 = 5376;
pub const ERR_TSK_STC: u32 = 8448;
pub const ERR_TSK_OWN: u32 = 8704;
pub const ERR_TSK_OFW: u32 = 8960;
pub const ERR_CRY_LEN: u32 = 12544;
pub const ERR_CRY_VAL: u32 = 12800;
pub const ERR_PAR_LEN: u32 = 16640;
pub const ERR_PAR_VAL: u32 = 16896;
pub const ERR_SEC_APP: u32 = 20736;
pub const ERR_SEC_CRC: u32 = 20992;
pub const ERR_SEC_CHK: u32 = 21248;
pub const ERR_SEC_KEY: u32 = 21504;
pub const ERR_SEC_PIN: u32 = 21760;
pub const ERR_SEC_SCP: u32 = 22016;
pub const ERR_SEC_SIG: u32 = 22272;
pub const ERR_SEC_MEM: u32 = 22528;
pub const ERR_SEC_STA: u32 = 22784;
pub const ERR_APD_CLA: u32 = 28160;
pub const ERR_APD_INS: u32 = 27904;
pub const ERR_APD_HDR: u32 = 25856;
pub const ERR_APD_STA: u32 = 26112;
pub const ERR_APD_LEN: u32 = 26368;
pub const ERR_APD_DAT: u32 = 26624;
pub const SWO_SUCCESS: u32 = 36864;
pub const SWO_OK: u32 = 0;
pub const SWO_KO: u32 = 1;
pub const EXCEPTION: u32 = 1;
pub const INVALID_PARAMETER: u32 = 2;
pub const EXCEPTION_SECURITY: u32 = 3;
pub const INVALID_STATE: u32 = 4;
pub const EXCEPTION_IO_RESET: u32 = 5;
pub const NOT_ENOUGH_SPACE: u32 = 6;
pub const EXCEPTION_OVERFLOW: u32 = 7;
pub const INVALID_CRC: u32 = 8;
pub const INVALID_CHECKSUM: u32 = 9;
pub const INVALID_COUNTER: u32 = 10;
pub const NOT_SUPPORTED: u32 = 11;
pub const TIMEOUT: u32 = 12;
pub const EXCEPTION_PIC: u32 = 13;
pub const EXCEPTION_APPEXIT: u32 = 14;
pub const EXCEPTION_IO_OVERFLOW: u32 = 15;
pub const EXCEPTION_IO_HEADER: u32 = 16;
pub const EXCEPTION_IO_STATE: u32 = 17;
pub const EXCEPTION_CXPORT: u32 = 18;
pub const EXCEPTION_SYSTEM: u32 = 19;
pub const OS_PARSE_BERTLV_OFFSET_COMPARE_WITH_BUFFER: u32 = 2147483648;
pub const OS_PARSE_BERTLV_OFFSET_GET_LENGTH: u32 = 1073741824;
pub const CX_HASH_MAX_BLOCK_COUNT: u32 = 65535;
pub const CX_RIPEMD160_SIZE: u32 = 20;
pub const CX_SHA224_SIZE: u32 = 28;
pub const CX_SHA256_SIZE: u32 = 32;
pub const CX_SHA384_SIZE: u32 = 48;
pub const CX_SHA512_SIZE: u32 = 64;
pub const CX_DES_KEY_LENGTH: u32 = 64;
pub const CX_3DES_2_KEY_LENGTH: u32 = 128;
pub const CX_3DES_3_KEY_LENGTH: u32 = 192;
pub const MAX_IV_LENGTH: u32 = 16;
pub const MAX_BLOCK_LENGTH: u32 = 16;
pub const CMAC_MAX_BLOCK_LENGTH: u32 = 16;
pub const AES_SIV_MAX_KEY_LEN: u32 = 32;
pub const AES_SIV_KEY_NUMBER: u32 = 2;
pub const AES_SIV_TAG_LEN: u32 = 16;
pub const CX_CRC16_INIT: u32 = 65535;
pub const ENDORSEMENT_MAX_ASN1_LENGTH: u32 = 72;
pub const BOLOS_TRUE: u32 = 170;
pub const BOLOS_FALSE: u32 = 85;
pub const BOLOS_UX_OK: u32 = 170;
pub const BOLOS_UX_CANCEL: u32 = 85;
pub const BOLOS_UX_ERROR: u32 = 214;
pub const BOLOS_UX_IGNORE: u32 = 151;
pub const BOLOS_UX_REDRAW: u32 = 105;
pub const BOLOS_UX_CONTINUE: u32 = 0;
pub const OS_FLAG_RECOVERY: u32 = 1;
pub const OS_FLAG_SIGNED_MCU_CODE: u32 = 2;
pub const OS_FLAG_ONBOARDED: u32 = 4;
pub const OS_FLAG_ISSUER_TRUSTED: u32 = 8;
pub const OS_FLAG_CUSTOMCA_TRUSTED: u32 = 16;
pub const OS_FLAG_HSM_INITIALIZED: u32 = 32;
pub const OS_FLAG_FACTORY_FILLED: u32 = 64;
pub const OS_FLAG_PIN_VALIDATED: u32 = 128;
pub const IMPL_IO_APDU_BUFFER_SIZE: u32 = 260;
pub const IO_APDU_BUFFER_SIZE: u32 = 260;
pub const CHANNEL_APDU: u32 = 0;
pub const CHANNEL_KEYBOARD: u32 = 1;
pub const CHANNEL_SPI: u32 = 2;
pub const IO_RESET_AFTER_REPLIED: u32 = 128;
pub const IO_RECEIVE_DATA: u32 = 64;
pub const IO_RETURN_AFTER_TX: u32 = 32;
pub const IO_ASYNCH_REPLY: u32 = 16;
pub const IO_FINISHED: u32 = 8;
pub const IO_FLAGS: u32 = 248;
pub const BLE_SEGMENT_SIZE: u32 = 64;
pub const NVM_ERASED_WORD_VALUE: u32 = 4294967295;
pub const DEFAULT_PIN_RETRIES: u32 = 3;
pub const BOLOS_APPNAME_MAX_SIZE_B: u32 = 32;
pub const BOLOS_APPVERSION_MAX_SIZE_B: u32 = 16;
pub const BOLOS_TAG_APPNAME: u32 = 1;
pub const BOLOS_TAG_APPVERSION: u32 = 2;
pub const BOLOS_TAG_ICON: u32 = 3;
pub const BOLOS_TAG_DERIVEPATH: u32 = 4;
pub const BOLOS_TAG_DATA_SIZE: u32 = 5;
pub const BOLOS_TAG_DEPENDENCY: u32 = 6;
pub const BOLOS_TAG_USER_TAG: u32 = 32;
pub const OS_REGISTRY_GET_TAG_OFFSET_COMPARE_WITH_BUFFER: u32 = 2147483648;
pub const OS_REGISTRY_GET_TAG_OFFSET_GET_LENGTH: u32 = 1073741824;
pub const BOLOS_UX_ONBOARDING_ALGORITHM_BIP39: u32 = 1;
pub const BOLOS_UX_ONBOARDING_ALGORITHM_ELECTRUM: u32 = 2;
pub const BOLOS_MASTER_SEED_LEN: u32 = 32;
pub const HDW_NORMAL: u32 = 0;
pub const HDW_ED25519_SLIP10: u32 = 1;
pub const HDW_SLIP21: u32 = 2;
pub const OS_SETTING_FEATURES_NFC_ENABLED: u32 = 1;
pub const OS_SETTING_FEATURES_NO_PIN_SHUFFLE: u32 = 2;
pub const OS_SETTING_FEATURES_BATT_IN_SIDE: u32 = 4;
pub const SYSCALL_get_api_level_ID: u32 = 1;
pub const SYSCALL_halt_ID: u32 = 2;
pub const SYSCALL_nvm_write_ID: u32 = 50331651;
pub const SYSCALL_nvm_erase_ID: u32 = 33554721;
pub const SYSCALL_cx_aes_set_key_hw_ID: u32 = 33554610;
pub const SYSCALL_cx_aes_reset_hw_ID: u32 = 179;
pub const SYSCALL_cx_aes_block_hw_ID: u32 = 33554612;
pub const SYSCALL_cx_des_set_key_hw_ID: u32 = 33554607;
pub const SYSCALL_cx_des_reset_hw_ID: u32 = 176;
pub const SYSCALL_cx_des_block_hw_ID: u32 = 33554609;
pub const SYSCALL_cx_bn_lock_ID: u32 = 33554706;
pub const SYSCALL_cx_bn_unlock_ID: u32 = 182;
pub const SYSCALL_cx_bn_is_locked_ID: u32 = 183;
pub const SYSCALL_cx_bn_alloc_ID: u32 = 33554707;
pub const SYSCALL_cx_bn_alloc_init_ID: u32 = 67109140;
pub const SYSCALL_cx_bn_destroy_ID: u32 = 16777404;
pub const SYSCALL_cx_bn_nbytes_ID: u32 = 33554701;
pub const SYSCALL_cx_bn_init_ID: u32 = 50331925;
pub const SYSCALL_cx_bn_rand_ID: u32 = 16777450;
pub const SYSCALL_cx_bn_copy_ID: u32 = 33554624;
pub const SYSCALL_cx_bn_set_u32_ID: u32 = 33554625;
pub const SYSCALL_cx_bn_get_u32_ID: u32 = 33554667;
pub const SYSCALL_cx_bn_export_ID: u32 = 50331843;
pub const SYSCALL_cx_bn_cmp_ID: u32 = 50331844;
pub const SYSCALL_cx_bn_cmp_u32_ID: u32 = 50331845;
pub const SYSCALL_cx_bn_is_odd_ID: u32 = 33554712;
pub const SYSCALL_cx_bn_xor_ID: u32 = 50331848;
pub const SYSCALL_cx_bn_or_ID: u32 = 50331849;
pub const SYSCALL_cx_bn_and_ID: u32 = 50331850;
pub const SYSCALL_cx_bn_tst_bit_ID: u32 = 50331851;
pub const SYSCALL_cx_bn_set_bit_ID: u32 = 33554636;
pub const SYSCALL_cx_bn_clr_bit_ID: u32 = 33554637;
pub const SYSCALL_cx_bn_shr_ID: u32 = 33554638;
pub const SYSCALL_cx_bn_shl_ID: u32 = 33554716;
pub const SYSCALL_cx_bn_cnt_bits_ID: u32 = 33554668;
pub const SYSCALL_cx_bn_add_ID: u32 = 50331929;
pub const SYSCALL_cx_bn_sub_ID: u32 = 50331930;
pub const SYSCALL_cx_bn_mul_ID: u32 = 50331858;
pub const SYSCALL_cx_bn_mod_add_ID: u32 = 67109075;
pub const SYSCALL_cx_bn_mod_sub_ID: u32 = 67109076;
pub const SYSCALL_cx_bn_mod_mul_ID: u32 = 67109077;
pub const SYSCALL_cx_bn_reduce_ID: u32 = 50331862;
pub const SYSCALL_cx_bn_mod_sqrt_ID: u32 = 67109149;
pub const SYSCALL_cx_bn_mod_pow_bn_ID: u32 = 67109079;
pub const SYSCALL_cx_bn_mod_pow_ID: u32 = 83886317;
pub const SYSCALL_cx_bn_mod_pow2_ID: u32 = 83886318;
pub const SYSCALL_cx_bn_mod_invert_nprime_ID: u32 = 50331866;
pub const SYSCALL_cx_bn_mod_u32_invert_ID: u32 = 50331926;
pub const SYSCALL_cx_bn_is_prime_ID: u32 = 33554671;
pub const SYSCALL_cx_bn_next_prime_ID: u32 = 16777456;
pub const SYSCALL_cx_bn_rng_ID: u32 = 33554909;
pub const SYSCALL_cx_bn_gf2_n_mul_ID: u32 = 83886150;
pub const SYSCALL_cx_mont_alloc_ID: u32 = 33554652;
pub const SYSCALL_cx_mont_init_ID: u32 = 33554653;
pub const SYSCALL_cx_mont_init2_ID: u32 = 50331870;
pub const SYSCALL_cx_mont_to_montgomery_ID: u32 = 50331871;
pub const SYSCALL_cx_mont_from_montgomery_ID: u32 = 50331872;
pub const SYSCALL_cx_mont_mul_ID: u32 = 67109089;
pub const SYSCALL_cx_mont_pow_ID: u32 = 83886306;
pub const SYSCALL_cx_mont_pow_bn_ID: u32 = 67109091;
pub const SYSCALL_cx_mont_invert_nprime_ID: u32 = 50331876;
pub const SYSCALL_cx_ecdomain_size_ID: u32 = 33554734;
pub const SYSCALL_cx_ecdomain_parameters_length_ID: u32 = 33554735;
pub const SYSCALL_cx_ecdomain_parameter_ID: u32 = 67109168;
pub const SYSCALL_cx_ecdomain_parameter_bn_ID: u32 = 50331953;
pub const SYSCALL_cx_ecdomain_generator_ID: u32 = 67109170;
pub const SYSCALL_cx_ecdomain_generator_bn_ID: u32 = 33554739;
pub const SYSCALL_cx_ecpoint_alloc_ID: u32 = 33554673;
pub const SYSCALL_cx_ecpoint_destroy_ID: u32 = 16777458;
pub const SYSCALL_cx_ecpoint_init_ID: u32 = 83886323;
pub const SYSCALL_cx_ecpoint_init_bn_ID: u32 = 50331892;
pub const SYSCALL_cx_ecpoint_export_ID: u32 = 83886325;
pub const SYSCALL_cx_ecpoint_export_bn_ID: u32 = 50331894;
pub const SYSCALL_cx_ecpoint_compress_ID: u32 = 67109164;
pub const SYSCALL_cx_ecpoint_decompress_ID: u32 = 67109165;
pub const SYSCALL_cx_ecpoint_add_ID: u32 = 50331918;
pub const SYSCALL_cx_ecpoint_neg_ID: u32 = 16777487;
pub const SYSCALL_cx_ecpoint_scalarmul_ID: u32 = 50331920;
pub const SYSCALL_cx_ecpoint_scalarmul_bn_ID: u32 = 33554705;
pub const SYSCALL_cx_ecpoint_rnd_scalarmul_ID: u32 = 50331943;
pub const SYSCALL_cx_ecpoint_rnd_scalarmul_bn_ID: u32 = 33554728;
pub const SYSCALL_cx_ecpoint_double_scalarmul_ID: u32 = 117440840;
pub const SYSCALL_cx_ecpoint_double_scalarmul_bn_ID: u32 = 83886410;
pub const SYSCALL_cx_ecpoint_cmp_ID: u32 = 50331899;
pub const SYSCALL_cx_ecpoint_is_on_curve_ID: u32 = 33554684;
pub const SYSCALL_cx_ecpoint_is_at_infinity_ID: u32 = 33554763;
pub const SYSCALL_cx_ecpoint_x25519_ID: u32 = 50331675;
pub const SYSCALL_cx_ecpoint_x448_ID: u32 = 50331744;
pub const SYSCALL_cx_crc32_hw_ID: u32 = 33554690;
pub const SYSCALL_cx_get_random_bytes_ID: u32 = 33554695;
pub const SYSCALL_cx_trng_get_random_data_ID: u32 = 33554694;
pub const SYSCALL_os_perso_erase_all_ID: u32 = 75;
pub const SYSCALL_os_perso_set_seed_ID: u32 = 67108942;
pub const SYSCALL_os_perso_derive_and_set_seed_ID: u32 = 117440591;
pub const SYSCALL_os_perso_set_words_ID: u32 = 33554512;
pub const SYSCALL_os_perso_finalize_ID: u32 = 81;
pub const SYSCALL_os_perso_is_pin_set_ID: u32 = 158;
pub const SYSCALL_os_perso_isonboarded_ID: u32 = 159;
pub const SYSCALL_os_perso_setonboardingstatus_ID: u32 = 50331796;
pub const SYSCALL_os_perso_derive_node_bip32_ID: u32 = 83886163;
pub const SYSCALL_os_perso_derive_node_with_seed_key_ID: u32 = 134217894;
pub const SYSCALL_os_perso_derive_eip2333_ID: u32 = 67109031;
pub const SYSCALL_os_endorsement_get_code_hash_ID: u32 = 16777301;
pub const SYSCALL_os_endorsement_get_public_key_ID: u32 = 50331734;
pub const SYSCALL_os_endorsement_get_public_key_certificate_ID: u32 = 50331735;
pub const SYSCALL_os_endorsement_key1_get_app_secret_ID: u32 = 16777304;
pub const SYSCALL_os_endorsement_key1_sign_data_ID: u32 = 50331737;
pub const SYSCALL_os_endorsement_key2_derive_sign_data_ID: u32 = 50331738;
pub const SYSCALL_os_perso_set_pin_ID: u32 = 67108940;
pub const SYSCALL_os_perso_set_current_identity_pin_ID: u32 = 33554509;
pub const SYSCALL_os_global_pin_is_validated_ID: u32 = 160;
pub const SYSCALL_os_global_pin_check_ID: u32 = 33554593;
pub const SYSCALL_os_global_pin_invalidate_ID: u32 = 93;
pub const SYSCALL_os_global_pin_retries_ID: u32 = 94;
pub const SYSCALL_os_registry_count_ID: u32 = 95;
pub const SYSCALL_os_registry_get_ID: u32 = 33554722;
pub const SYSCALL_os_ux_ID: u32 = 16777316;
pub const SYSCALL_os_ux_result_ID: u32 = 16777317;
pub const SYSCALL_os_lib_call_ID: u32 = 16777319;
pub const SYSCALL_os_lib_end_ID: u32 = 104;
pub const SYSCALL_os_flags_ID: u32 = 106;
pub const SYSCALL_os_version_ID: u32 = 33554539;
pub const SYSCALL_os_serial_ID: u32 = 33554540;
pub const SYSCALL_os_seph_features_ID: u32 = 110;
pub const SYSCALL_os_seph_version_ID: u32 = 33554543;
pub const SYSCALL_os_bootloader_version_ID: u32 = 33554547;
pub const SYSCALL_os_setting_get_ID: u32 = 50331760;
pub const SYSCALL_os_setting_set_ID: u32 = 50331761;
pub const SYSCALL_os_get_memory_info_ID: u32 = 16777330;
pub const SYSCALL_os_registry_get_tag_ID: u32 = 100663587;
pub const SYSCALL_os_registry_get_current_app_tag_ID: u32 = 50331764;
pub const SYSCALL_os_registry_delete_app_and_dependees_ID: u32 = 16777508;
pub const SYSCALL_os_registry_delete_all_apps_ID: u32 = 293;
pub const SYSCALL_os_sched_exec_ID: u32 = 16777510;
pub const SYSCALL_os_sched_exit_ID: u32 = 16777370;
pub const SYSCALL_os_sched_is_running_ID: u32 = 16777371;
pub const SYSCALL_os_sched_create_ID: u32 = 117440795;
pub const SYSCALL_os_sched_kill_ID: u32 = 16777336;
pub const SYSCALL_io_seph_send_ID: u32 = 33554563;
pub const SYSCALL_io_seph_is_status_sent_ID: u32 = 132;
pub const SYSCALL_io_seph_recv_ID: u32 = 50331781;
pub const SYSCALL_nvm_write_page_ID: u32 = 16777482;
pub const SYSCALL_nvm_erase_page_ID: u32 = 16777526;
pub const SYSCALL_try_context_get_ID: u32 = 135;
pub const SYSCALL_try_context_set_ID: u32 = 16777483;
pub const SYSCALL_os_sched_last_status_ID: u32 = 16777372;
pub const SYSCALL_os_sched_yield_ID: u32 = 16777373;
pub const SYSCALL_os_sched_switch_ID: u32 = 33554590;
pub const SYSCALL_os_sched_current_task_ID: u32 = 139;
pub const SYSCALL_os_allow_protected_flash_ID: u32 = 142;
pub const SYSCALL_os_deny_protected_flash_ID: u32 = 145;
pub const SYSCALL_os_allow_protected_ram_ID: u32 = 146;
pub const SYSCALL_os_deny_protected_ram_ID: u32 = 147;
pub const SYSCALL_os_customca_verify_ID: u32 = 50331792;
pub const SYSCALL_screen_clear_ID: u32 = 121;
pub const SYSCALL_screen_update_ID: u32 = 122;
pub const SYSCALL_screen_set_keepout_ID: u32 = 67108987;
pub const SYSCALL_bagl_hal_draw_bitmap_within_rect_ID: u32 = 150995068;
pub const SYSCALL_bagl_hal_draw_rect_ID: u32 = 83886205;
pub const SYSCALL_os_ux_set_status_ID_IN: u32 = 33554740;
pub const SYSCALL_os_ux_get_status_ID_IN: u32 = 16777525;
pub const SYSCALL_io_button_read_ID: u32 = 143;
pub const SYSCALL_os_seph_serial_ID: u32 = 33554541;
pub const CXPORT_ED_DES: u32 = 1;
pub const CXPORT_ED_AES: u32 = 2;
pub const CXPORT_ED_RSA: u32 = 4;
pub const BLE_CMD_APDU: u32 = 5;
pub const BLE_CHUNK_LENGTH: u32 = 20;
pub const M24SR_CHUNK_LENGTH: u32 = 246;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT: u32 = 1;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_REQBLE: u32 = 1;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_RECOVERY: u32 = 2;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FLASHBACK: u32 = 4;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_BOOTMENU: u32 = 8;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_USB: u32 = 1;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BLE: u32 = 2;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_TOUCH: u32 = 4;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BUTTON_COUNT: u32 = 240;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BUTTON_COUNT_POS: u32 = 4;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_MASK: u32 = 3840;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_NO_SCREEN: u32 = 0;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_BIG: u32 = 256;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_SML: u32 = 512;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_SSD1312: u32 = 768;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_LEDRGB: u32 = 4096;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BATTERY: u32 = 8;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_MASK: u32 = 4026531840;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_BASIC: u32 = 0;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_MCUSEC: u32 = 268435456;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_MCUBL: u32 = 536870912;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_EVENT: u32 = 2;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_LOADED_EVENT: u32 = 0;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_DUMP_EVENT: u32 = 1;
pub const SEPROXYHAL_TAG_BLE_WRITE_REQUEST_EVENT: u32 = 3;
pub const SEPROXYHAL_TAG_BLE_READ_REQUEST_EVENT: u32 = 4;
pub const SEPROXYHAL_TAG_BUTTON_PUSH_EVENT: u32 = 5;
pub const SEPROXYHAL_TAG_BUTTON_PUSH_ID_MASK: u32 = 254;
pub const SEPROXYHAL_TAG_BUTTON_PUSH_INTERVAL_MS: u32 = 100;
pub const SEPROXYHAL_TAG_NFC_FIELD_DETECTION_EVENT: u32 = 6;
pub const SEPROXYHAL_TAG_NFC_APDU_RECEIVED_EVENT: u32 = 7;
pub const SEPROXYHAL_TAG_BATTERY_NOTIFICATION_EVENT: u32 = 8;
pub const SEPROXYHAL_TAG_M24SR_GPO_CHANGE_EVENT: u32 = 9;
pub const SEPROXYHAL_TAG_M24SR_RESPONSE_APDU_EVENT: u32 = 10;
pub const SEPROXYHAL_TAG_BLE_NOTIFY_INDICATE_EVENT: u32 = 11;
pub const SEPROXYHAL_TAG_FINGER_EVENT: u32 = 12;
pub const SEPROXYHAL_TAG_FINGER_EVENT_TOUCH: u32 = 1;
pub const SEPROXYHAL_TAG_FINGER_EVENT_RELEASE: u32 = 2;
pub const SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT: u32 = 13;
pub const SEPROXYHAL_TAG_TICKER_EVENT: u32 = 14;
pub const SEPROXYHAL_TAG_USB_EVENT: u32 = 15;
pub const SEPROXYHAL_TAG_USB_EVENT_RESET: u32 = 1;
pub const SEPROXYHAL_TAG_USB_EVENT_SOF: u32 = 2;
pub const SEPROXYHAL_TAG_USB_EVENT_SUSPENDED: u32 = 4;
pub const SEPROXYHAL_TAG_USB_EVENT_RESUMED: u32 = 8;
pub const SEPROXYHAL_TAG_USB_EP_XFER_EVENT: u32 = 16;
pub const SEPROXYHAL_TAG_USB_EP_XFER_SETUP: u32 = 1;
pub const SEPROXYHAL_TAG_USB_EP_XFER_IN: u32 = 2;
pub const SEPROXYHAL_TAG_USB_EP_XFER_OUT: u32 = 4;
pub const SEPROXYHAL_TAG_BLE_CONNECTION_EVENT: u32 = 17;
pub const SEPROXYHAL_TAG_UNSEC_CHUNK_EVENT: u32 = 18;
pub const SEPROXYHAL_TAG_ACK_LINK_SPEED: u32 = 19;
pub const SEPROXYHAL_TAG_BLUENRG_RECV_EVENT: u32 = 20;
pub const SEPROXYHAL_TAG_STATUS_EVENT: u32 = 21;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_CHARGING: u32 = 1;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_USB_ON: u32 = 2;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_BLE_ON: u32 = 4;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_USB_POWERED: u32 = 8;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_CHARGING_ISSUE: u32 = 16;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_TEMPERATURE_ISSUE: u32 = 32;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_BATTERY_ISSUE: u32 = 64;
pub const SEPROXYHAL_TAG_CAPDU_EVENT: u32 = 22;
pub const SEPROXYHAL_TAG_I2C_EVENT: u32 = 23;
pub const SEPROXYHAL_TAG_I2C_EVENT_KIND_READ: u32 = 1;
pub const SEPROXYHAL_TAG_I2C_EVENT_KIND_WRITE: u32 = 2;
pub const SEPROXYHAL_TAG_BLE_RECV_EVENT: u32 = 24;
pub const SEPROXYHAL_TAG_BOOTLOADER_RAPDU_EVENT: u32 = 25;
pub const SEPROXYHAL_TAG_UX_EVENT: u32 = 26;
pub const SEPH_PROTOCOL_EVT_POWER_BUTTON_EVENT: u32 = 27;
pub const SEPROXYHAL_TAG_MCU: u32 = 49;
pub const SEPROXYHAL_TAG_MCU_TYPE_BOOTLOADER: u32 = 0;
pub const SEPROXYHAL_TAG_MCU_TYPE_LOCK: u32 = 1;
pub const SEPROXYHAL_TAG_MCU_TYPE_PROTECT: u32 = 2;
pub const SEPROXYHAL_TAG_MCU_TYPE_BD_ADDR: u32 = 3;
pub const SEPROXYHAL_TAG_MCU_BOOTLOADER: u32 = 49;
pub const SEPROXYHAL_TAG_UNSEC_CHUNK_READ: u32 = 50;
pub const SEPROXYHAL_TAG_UNSEC_CHUNK_READ_EXT: u32 = 51;
pub const SEPROXYHAL_TAG_BLE_SEND: u32 = 56;
pub const SEPROXYHAL_TAG_SET_SCREEN_CONFIG: u32 = 62;
pub const SEPROXYHAL_TAG_SET_LINK_PROP: u32 = 63;
pub const SEPROXYHAL_TAG_BLUENRG_SEND: u32 = 64;
pub const SEPROXYHAL_TAG_BLE_DEFINE_GENERIC_SETTING: u32 = 65;
pub const SEPROXYHAL_TAG_BLE_DEFINE_SERVICE_SETTING: u32 = 66;
pub const SEPROXYHAL_TAG_NFC_DEFINE_SERVICE_SETTING: u32 = 67;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER: u32 = 68;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_ACTION_ON: u32 = 2;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_ACTION_DBWIPE: u32 = 4;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_FACTORY_TEST: u32 = 64;
pub const SEPROXYHAL_TAG_NFC_RADIO_POWER: u32 = 69;
pub const SEPROXYHAL_TAG_SE_POWER_OFF: u32 = 70;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB: u32 = 72;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_CMD_READ: u32 = 1;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_CMD_WRITE: u32 = 2;
pub const SEPROXYHAL_TAG_BATTERY_CHARGE: u32 = 73;
pub const SEPROXYHAL_TAG_DEVICE_OFF: u32 = 75;
pub const SEPROXYHAL_TAG_MORE_TIME: u32 = 76;
pub const SEPROXYHAL_TAG_M24SR_C_APDU: u32 = 77;
pub const SEPROXYHAL_TAG_SET_TICKER_INTERVAL: u32 = 78;
pub const SEPROXYHAL_TAG_USB_CONFIG: u32 = 79;
pub const SEPROXYHAL_TAG_USB_CONFIG_CONNECT: u32 = 1;
pub const SEPROXYHAL_TAG_USB_CONFIG_DISCONNECT: u32 = 2;
pub const SEPROXYHAL_TAG_USB_CONFIG_ADDR: u32 = 3;
pub const SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS: u32 = 4;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_DISABLED: u32 = 0;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_CONTROL: u32 = 1;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_INTERRUPT: u32 = 2;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_BULK: u32 = 3;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_ISOCHRONOUS: u32 = 4;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE: u32 = 80;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_SETUP: u32 = 16;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN: u32 = 32;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_OUT: u32 = 48;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_STALL: u32 = 64;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_UNSTALL: u32 = 128;
pub const SEPROXYHAL_TAG_SET_LED: u32 = 81;
pub const SEPROXYHAL_TAG_REQUEST_STATUS: u32 = 82;
pub const SEPROXYHAL_TAG_RAPDU: u32 = 83;
pub const SEPROXYHAL_TAG_I2C_XFER: u32 = 84;
pub const SEPROXYHAL_TAG_UX_CMD: u32 = 93;
pub const SEPROXYHAL_TAG_UX_CMD_BLE_DISABLE_ADV: u32 = 0;
pub const SEPROXYHAL_TAG_UX_CMD_BLE_ENABLE_ADV: u32 = 1;
pub const SEPROXYHAL_TAG_UX_CMD_BLE_RESET_PAIRINGS: u32 = 2;
pub const SEPROXYHAL_TAG_UX_CMD_REDISPLAY: u32 = 3;
pub const SEPROXYHAL_TAG_UX_CMD_BLE_NAME_CHANGED: u32 = 4;
pub const SEPROXYHAL_TAG_SET_TOUCH_STATE: u32 = 91;
pub const SEPROXYHAL_TAG_PRINTF: u32 = 95;
pub const SEPROXYHAL_TAG_DBG_SCREEN_DISPLAY_STATUS: u32 = 94;
pub const SEPROXYHAL_TAG_STATUS_MASK: u32 = 96;
pub const SEPROXYHAL_TAG_GENERAL_STATUS: u32 = 96;
pub const SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND: u32 = 0;
pub const SEPROXYHAL_TAG_PAIRING_STATUS: u32 = 97;
pub const SEPROXYHAL_TAG_BLE_READ_RESPONSE_STATUS: u32 = 98;
pub const SEPROXYHAL_TAG_NFC_READ_RESPONSE_STATUS: u32 = 99;
pub const SEPROXYHAL_TAG_BLE_NOTIFY_INDICATE_STATUS: u32 = 100;
pub const SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS: u32 = 101;
pub const SEPROXYHAL_TAG_PRINTF_STATUS: u32 = 102;
pub const SEPROXYHAL_TAG_SET_LINK_SPEED: u32 = 103;
pub const SEPROXYHAL_TAG_SCREEN_ANIMATION_STATUS: u32 = 104;
pub const SEPROXYHAL_TAG_SCREEN_ANIMATION_STATUS_VERTICAL_SPLIT_SLIDE: u32 = 0;
pub const SEPROXYHAL_TAG_BOOTLOADER_CAPDU_STATUS: u32 = 106;
pub const IO_CACHE: u32 = 1;
pub const NO_TIMEOUT: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const USBD_MAX_NUM_INTERFACES: u32 = 3;
pub const USBD_MAX_NUM_CONFIGURATION: u32 = 1;
pub const USBD_MAX_STR_DESC_SIZ: u32 = 512;
pub const USBD_SUPPORT_USER_STRING: u32 = 0;
pub const USBD_DEBUG_LEVEL: u32 = 0;
pub const USBD_LPM_ENABLED: u32 = 1;
pub const USBD_SELF_POWERED: u32 = 1;
pub const DEVICE_FS: u32 = 0;
pub const USB_LEN_DEV_QUALIFIER_DESC: u32 = 10;
pub const USB_LEN_DEV_DESC: u32 = 18;
pub const USB_LEN_CFG_DESC: u32 = 9;
pub const USB_LEN_IF_DESC: u32 = 9;
pub const USB_LEN_EP_DESC: u32 = 7;
pub const USB_LEN_OTG_DESC: u32 = 3;
pub const USB_LEN_LANGID_STR_DESC: u32 = 4;
pub const USB_LEN_OTHER_SPEED_DESC_SIZ: u32 = 9;
pub const USBD_IDX_LANGID_STR: u32 = 0;
pub const USBD_IDX_MFC_STR: u32 = 1;
pub const USBD_IDX_PRODUCT_STR: u32 = 2;
pub const USBD_IDX_SERIAL_STR: u32 = 3;
pub const USBD_IDX_CONFIG_STR: u32 = 4;
pub const USBD_IDX_INTERFACE_STR: u32 = 5;
pub const USB_REQ_TYPE_STANDARD: u32 = 0;
pub const USB_REQ_TYPE_CLASS: u32 = 32;
pub const USB_REQ_TYPE_VENDOR: u32 = 64;
pub const USB_REQ_TYPE_MASK: u32 = 96;
pub const USB_REQ_RECIPIENT_DEVICE: u32 = 0;
pub const USB_REQ_RECIPIENT_INTERFACE: u32 = 1;
pub const USB_REQ_RECIPIENT_ENDPOINT: u32 = 2;
pub const USB_REQ_RECIPIENT_MASK: u32 = 3;
pub const USB_REQ_GET_STATUS: u32 = 0;
pub const USB_REQ_CLEAR_FEATURE: u32 = 1;
pub const USB_REQ_SET_FEATURE: u32 = 3;
pub const USB_REQ_SET_ADDRESS: u32 = 5;
pub const USB_REQ_GET_DESCRIPTOR: u32 = 6;
pub const USB_REQ_SET_DESCRIPTOR: u32 = 7;
pub const USB_REQ_GET_CONFIGURATION: u32 = 8;
pub const USB_REQ_SET_CONFIGURATION: u32 = 9;
pub const USB_REQ_GET_INTERFACE: u32 = 10;
pub const USB_REQ_SET_INTERFACE: u32 = 11;
pub const USB_REQ_SYNCH_FRAME: u32 = 12;
pub const USB_DESC_TYPE_DEVICE: u32 = 1;
pub const USB_DESC_TYPE_CONFIGURATION: u32 = 2;
pub const USB_DESC_TYPE_STRING: u32 = 3;
pub const USB_DESC_TYPE_INTERFACE: u32 = 4;
pub const USB_DESC_TYPE_ENDPOINT: u32 = 5;
pub const USB_DESC_TYPE_DEVICE_QUALIFIER: u32 = 6;
pub const USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION: u32 = 7;
pub const USB_DESC_TYPE_BOS: u32 = 15;
pub const USB_CONFIG_REMOTE_WAKEUP: u32 = 2;
pub const USB_CONFIG_SELF_POWERED: u32 = 1;
pub const USB_FEATURE_EP_HALT: u32 = 0;
pub const USB_FEATURE_REMOTE_WAKEUP: u32 = 1;
pub const USB_FEATURE_TEST_MODE: u32 = 2;
pub const USB_DEVICE_CAPABITY_TYPE: u32 = 16;
pub const USB_HS_MAX_PACKET_SIZE: u32 = 512;
pub const USB_FS_MAX_PACKET_SIZE: u32 = 64;
pub const USB_MAX_EP0_SIZE: u32 = 64;
pub const USBD_STATE_DEFAULT: u32 = 1;
pub const USBD_STATE_ADDRESSED: u32 = 2;
pub const USBD_STATE_CONFIGURED: u32 = 3;
pub const USBD_STATE_SUSPENDED: u32 = 4;
pub const USBD_EP0_IDLE: u32 = 0;
pub const USBD_EP0_SETUP: u32 = 1;
pub const USBD_EP0_DATA_IN: u32 = 2;
pub const USBD_EP0_DATA_OUT: u32 = 3;
pub const USBD_EP0_STATUS_IN: u32 = 4;
pub const USBD_EP0_STATUS_OUT: u32 = 5;
pub const USBD_EP0_STALL: u32 = 6;
pub const USBD_EP_TYPE_CTRL: u32 = 0;
pub const USBD_EP_TYPE_ISOC: u32 = 1;
pub const USBD_EP_TYPE_BULK: u32 = 2;
pub const USBD_EP_TYPE_INTR: u32 = 3;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_longlong;
pub type __uint64_t = ::core::ffi::c_ulonglong;
pub type __int_least8_t = ::core::ffi::c_schar;
pub type __uint_least8_t = ::core::ffi::c_uchar;
pub type __int_least16_t = ::core::ffi::c_short;
pub type __uint_least16_t = ::core::ffi::c_ushort;
pub type __int_least32_t = ::core::ffi::c_int;
pub type __uint_least32_t = ::core::ffi::c_uint;
pub type __int_least64_t = ::core::ffi::c_longlong;
pub type __uint_least64_t = ::core::ffi::c_ulonglong;
pub type __intmax_t = ::core::ffi::c_longlong;
pub type __uintmax_t = ::core::ffi::c_ulonglong;
pub type __intptr_t = ::core::ffi::c_int;
pub type __uintptr_t = ::core::ffi::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type int_fast16_t = ::core::ffi::c_short;
pub type uint_fast16_t = ::core::ffi::c_ushort;
pub type int_fast32_t = ::core::ffi::c_int;
pub type uint_fast32_t = ::core::ffi::c_uint;
pub type int_fast64_t = ::core::ffi::c_longlong;
pub type uint_fast64_t = ::core::ffi::c_ulonglong;
pub type wchar_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __gnuc_va_list = u32;
pub type va_list = __gnuc_va_list;
pub type wint_t = ::core::ffi::c_int;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blksize_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
pub type __dev_t = ::core::ffi::c_short;
pub type __uid_t = ::core::ffi::c_ushort;
pub type __gid_t = ::core::ffi::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = ::core::ffi::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::core::ffi::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::core::ffi::c_long;
pub type _fpos_t = ::core::ffi::c_long;
pub type __size_t = ::core::ffi::c_uint;
pub type _ssize_t = ::core::ffi::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::core::ffi::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for _mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for _mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _iconv_t = *mut ::core::ffi::c_void;
pub type __clock_t = ::core::ffi::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::core::ffi::c_ulong;
pub type __daddr_t = ::core::ffi::c_long;
pub type __timer_t = ::core::ffi::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::core::ffi::c_int;
pub type __nlink_t = ::core::ffi::c_ushort;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_ulong;
pub type __va_list = u32;
pub type __ULong = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::core::ffi::c_int,
    pub _maxwds: ::core::ffi::c_int,
    pub _sign: ::core::ffi::c_int,
    pub _wds: ::core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    const UNINIT: ::core::mem::MaybeUninit<_Bigint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Bigint>(),
        24usize,
        concat!("Size of: ", stringify!(_Bigint))
    );
    assert_eq!(
        ::core::mem::align_of::<_Bigint>(),
        4usize,
        concat!("Alignment of ", stringify!(_Bigint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._k) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._maxwds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_maxwds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sign) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_wds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_x)
        )
    );
}
impl Default for _Bigint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::core::ffi::c_int,
    pub __tm_min: ::core::ffi::c_int,
    pub __tm_hour: ::core::ffi::c_int,
    pub __tm_mday: ::core::ffi::c_int,
    pub __tm_mon: ::core::ffi::c_int,
    pub __tm_year: ::core::ffi::c_int,
    pub __tm_wday: ::core::ffi::c_int,
    pub __tm_yday: ::core::ffi::c_int,
    pub __tm_isdst: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    const UNINIT: ::core::mem::MaybeUninit<__tm> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__tm>(),
        36usize,
        concat!("Size of: ", stringify!(__tm))
    );
    assert_eq!(
        ::core::mem::align_of::<__tm>(),
        4usize,
        concat!("Alignment of ", stringify!(__tm))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_isdst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut ::core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    const UNINIT: ::core::mem::MaybeUninit<_on_exit_args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_on_exit_args>(),
        264usize,
        concat!("Size of: ", stringify!(_on_exit_args))
    );
    assert_eq!(
        ::core::mem::align_of::<_on_exit_args>(),
        4usize,
        concat!("Alignment of ", stringify!(_on_exit_args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fnargs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fnargs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._dso_handle) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_dso_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fntypes) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fntypes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._is_cxa) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_is_cxa)
        )
    );
}
impl Default for _on_exit_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::core::ffi::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    const UNINIT: ::core::mem::MaybeUninit<_atexit> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_atexit>(),
        140usize,
        concat!("Size of: ", stringify!(_atexit))
    );
    assert_eq!(
        ::core::mem::align_of::<_atexit>(),
        4usize,
        concat!("Alignment of ", stringify!(_atexit))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ind) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_ind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_fns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._on_exit_args_ptr) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_on_exit_args_ptr)
        )
    );
}
impl Default for _atexit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::core::ffi::c_uchar,
    pub _size: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::core::mem::MaybeUninit<__sbuf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sbuf>(),
        8usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<__sbuf>(),
        4usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
impl Default for __sbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::core::ffi::c_uchar,
    pub _r: ::core::ffi::c_int,
    pub _w: ::core::ffi::c_int,
    pub _flags: ::core::ffi::c_short,
    pub _file: ::core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::core::ffi::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut ::core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *mut ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *const ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: _fpos_t,
            arg4: ::core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::core::ffi::c_uchar,
    pub _ur: ::core::ffi::c_int,
    pub _ubuf: [::core::ffi::c_uchar; 3usize],
    pub _nbuf: [::core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::core::ffi::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::core::mem::MaybeUninit<__sFILE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sFILE>(),
        104usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::core::mem::align_of::<__sFILE>(),
        4usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._data) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._up) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbstate) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
impl Default for __sFILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __FILE = __sFILE;
extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::core::ffi::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    const UNINIT: ::core::mem::MaybeUninit<_glue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_glue>(),
        12usize,
        concat!("Size of: ", stringify!(_glue))
    );
    assert_eq!(
        ::core::mem::align_of::<_glue>(),
        4usize,
        concat!("Alignment of ", stringify!(_glue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._niobs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_niobs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._iobs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_iobs)
        )
    );
}
impl Default for _glue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::core::ffi::c_ushort; 3usize],
    pub _mult: [::core::ffi::c_ushort; 3usize],
    pub _add: ::core::ffi::c_ushort,
    pub _rand_next: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout__rand48() {
    const UNINIT: ::core::mem::MaybeUninit<_rand48> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_rand48>(),
        24usize,
        concat!("Size of: ", stringify!(_rand48))
    );
    assert_eq!(
        ::core::mem::align_of::<_rand48>(),
        8usize,
        concat!("Alignment of ", stringify!(_rand48))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_seed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mult) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_mult)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._add) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_add)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._rand_next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_rand_next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: ::core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
#[test]
fn bindgen_test_layout__mprec() {
    const UNINIT: ::core::mem::MaybeUninit<_mprec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mprec>(),
        16usize,
        concat!("Size of: ", stringify!(_mprec))
    );
    assert_eq!(
        ::core::mem::align_of::<_mprec>(),
        4usize,
        concat!("Alignment of ", stringify!(_mprec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mprec),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result_k) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mprec),
            "::",
            stringify!(_result_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p5s) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_mprec),
            "::",
            stringify!(_p5s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freelist) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_mprec),
            "::",
            stringify!(_freelist)
        )
    );
}
impl Default for _mprec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut ::core::ffi::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [::core::ffi::c_char; 8usize],
    pub _getdate_err: ::core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
#[test]
fn bindgen_test_layout__misc_reent() {
    const UNINIT: ::core::mem::MaybeUninit<_misc_reent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_misc_reent>(),
        80usize,
        concat!("Size of: ", stringify!(_misc_reent))
    );
    assert_eq!(
        ::core::mem::align_of::<_misc_reent>(),
        4usize,
        concat!("Alignment of ", stringify!(_misc_reent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._strtok_last) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_strtok_last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mblen_state) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_mblen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wctomb_state) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_wctomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbtowc_state) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_mbtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._l64a_buf) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_l64a_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._getdate_err) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_getdate_err)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrlen_state) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_mbrlen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrtowc_state) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_mbrtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbsrtowcs_state) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_mbsrtowcs_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcrtomb_state) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_wcrtomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcsrtombs_state) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_misc_reent),
            "::",
            stringify!(_wcsrtombs_state)
        )
    );
}
impl Default for _misc_reent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent {
    pub _errno: ::core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::core::ffi::c_int,
    pub _emergency: *mut ::core::ffi::c_char,
    pub _locale: *mut __locale_t,
    pub _mp: *mut _mprec,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _gamma_signgam: ::core::ffi::c_int,
    pub _cvtlen: ::core::ffi::c_int,
    pub _cvtbuf: *mut ::core::ffi::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut ::core::ffi::c_char,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut ::core::ffi::c_char,
}
#[test]
fn bindgen_test_layout__reent() {
    const UNINIT: ::core::mem::MaybeUninit<_reent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent>(),
        76usize,
        concat!("Size of: ", stringify!(_reent))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent>(),
        4usize,
        concat!("Alignment of ", stringify!(_reent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._errno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_errno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stderr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stderr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._inc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_inc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._emergency) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_emergency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._locale) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_locale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mp) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_mp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cleanup) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__cleanup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._gamma_signgam) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_gamma_signgam)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtlen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtbuf) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r48) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_r48)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._localtime_buf) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_localtime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._asctime_buf) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_asctime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sig_func) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_sig_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._misc) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_misc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._signal_buf) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_signal_buf)
        )
    );
}
impl Default for _reent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __assert(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_func(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: *const ::core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _impure_data: _reent;
}
extern "C" {
    pub static mut __atexit: *mut _atexit;
}
extern "C" {
    pub static mut __atexit0: _atexit;
}
extern "C" {
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> ::core::ffi::c_int,
        >,
        arg3: *mut _glue,
    ) -> ::core::ffi::c_int;
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
pub type off_t = __off_t;
extern "C" {
    pub fn ctermid(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::core::ffi::c_char, arg2: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fputc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::core::ffi::c_char, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn putc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ungetc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut ::core::ffi::c_void,
        _size: ::core::ffi::c_uint,
        _n: ::core::ffi::c_uint,
        arg2: *mut FILE,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const ::core::ffi::c_void,
        _size: ::core::ffi::c_uint,
        _n: ::core::ffi::c_uint,
        arg2: *mut FILE,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::core::ffi::c_long,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn perror(arg1: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn fopen(_name: *const ::core::ffi::c_char, _type: *const ::core::ffi::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
        arg3: *const ::core::ffi::c_char,
        arg4: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const ::core::ffi::c_char, arg2: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn diprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn viprintf(arg1: *const ::core::ffi::c_char, arg2: __gnuc_va_list) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn viscanf(arg1: *const ::core::ffi::c_char, arg2: __gnuc_va_list) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fdopen(arg1: ::core::ffi::c_int, arg2: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ::core::ffi::c_char, arg2: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::core::ffi::c_char, arg3: ::core::ffi::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putw(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut ::core::ffi::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fsetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const fpos_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: ::core::ffi::c_long,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _iprintf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _iscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn _printf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const ::core::ffi::c_char,
        _new: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char, ...)
        -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char)
        -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: ::core::ffi::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const ::core::ffi::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *mut ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *const ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __off: fpos_t,
                __whence: ::core::ffi::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const ::core::ffi::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *mut ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *const ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __off: fpos_t,
                __whence: ::core::ffi::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> *mut FILE;
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const ::core::ffi::c_void, arg2: *mut ::core::ffi::c_void, arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_uint);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::core::ffi::c_void, arg2: usize);
}
extern "C" {
    pub fn ffs(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fls(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn index(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strerror(arg1: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: ::core::ffi::c_int, arg2: locale_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _strdup_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strndup(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
        arg4: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strnlen(arg1: *const ::core::ffi::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strsignal(__signo: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn assert_exit(confirm: bool);
}
pub type cx_err_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_aes_key_s {
    pub size: usize,
    pub keys: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_cx_aes_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_aes_key_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_aes_key_s>(),
        36usize,
        concat!("Size of: ", stringify!(cx_aes_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_aes_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_aes_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_key_s),
            "::",
            stringify!(keys)
        )
    );
}
pub type cx_aes_key_t = cx_aes_key_s;
extern "C" {
    pub fn cx_aes_set_key_hw(key: *const cx_aes_key_t, mode: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_reset_hw();
}
extern "C" {
    pub fn cx_aes_block_hw(
        inblock: *const ::core::ffi::c_uchar,
        outblock: *mut ::core::ffi::c_uchar,
    ) -> cx_err_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_des_key_s {
    pub size: u8,
    pub keys: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_cx_des_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_des_key_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_des_key_s>(),
        25usize,
        concat!("Size of: ", stringify!(cx_des_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_des_key_s>(),
        1usize,
        concat!("Alignment of ", stringify!(cx_des_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_des_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_des_key_s),
            "::",
            stringify!(keys)
        )
    );
}
pub type cx_des_key_t = cx_des_key_s;
extern "C" {
    pub fn cx_des_set_key_hw(keys: *const cx_des_key_t, mode: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_des_reset_hw();
}
extern "C" {
    pub fn cx_des_block_hw(
        inblock: *const ::core::ffi::c_uchar,
        outblock: *mut ::core::ffi::c_uchar,
    );
}
pub type cx_bn_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_bn_mont_ctx_t {
    pub n: cx_bn_t,
    pub h: cx_bn_t,
}
#[test]
fn bindgen_test_layout_cx_bn_mont_ctx_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_bn_mont_ctx_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_bn_mont_ctx_t>(),
        8usize,
        concat!("Size of: ", stringify!(cx_bn_mont_ctx_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_bn_mont_ctx_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_bn_mont_ctx_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_bn_mont_ctx_t),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_bn_mont_ctx_t),
            "::",
            stringify!(h)
        )
    );
}
extern "C" {
    pub fn cx_bn_lock(word_nbytes: usize, flags: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_unlock() -> u32;
}
extern "C" {
    pub fn cx_bn_is_locked() -> bool;
}
extern "C" {
    pub fn cx_bn_locked() -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_alloc(x: *mut cx_bn_t, nbytes: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_alloc_init(
        x: *mut cx_bn_t,
        nbytes: usize,
        value: *const u8,
        value_nbytes: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_destroy(x: *mut cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_nbytes(x: cx_bn_t, nbytes: *mut usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_init(x: cx_bn_t, value: *const u8, value_nbytes: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_rand(x: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_copy(a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_set_u32(x: cx_bn_t, n: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_get_u32(x: cx_bn_t, n: *mut u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_export(x: cx_bn_t, bytes: *mut u8, nbytes: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_cmp(a: cx_bn_t, b: cx_bn_t, diff: *mut ::core::ffi::c_int) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_cmp_u32(a: cx_bn_t, b: u32, diff: *mut ::core::ffi::c_int) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_is_odd(n: cx_bn_t, odd: *mut bool) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_xor(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_or(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_and(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_tst_bit(x: cx_bn_t, pos: u32, set: *mut bool) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_set_bit(x: cx_bn_t, pos: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_clr_bit(x: cx_bn_t, pos: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_shr(x: cx_bn_t, n: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_shl(x: cx_bn_t, n: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_cnt_bits(n: cx_bn_t, nbits: *mut u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_add(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_sub(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mul(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_add(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_sub(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_mul(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_reduce(r: cx_bn_t, d: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_sqrt(r: cx_bn_t, a: cx_bn_t, n: cx_bn_t, sign: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_pow_bn(r: cx_bn_t, a: cx_bn_t, e: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_pow(r: cx_bn_t, a: cx_bn_t, e: *const u8, e_len: u32, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_pow2(r: cx_bn_t, a: cx_bn_t, e: *const u8, e_len: u32, n: cx_bn_t)
        -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_invert_nprime(r: cx_bn_t, a: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_mod_u32_invert(r: cx_bn_t, a: u32, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_alloc(ctx: *mut cx_bn_mont_ctx_t, length: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_init(ctx: *mut cx_bn_mont_ctx_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_init2(ctx: *mut cx_bn_mont_ctx_t, n: cx_bn_t, h: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_to_montgomery(x: cx_bn_t, z: cx_bn_t, ctx: *const cx_bn_mont_ctx_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_from_montgomery(
        z: cx_bn_t,
        x: cx_bn_t,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_mul(
        r: cx_bn_t,
        a: cx_bn_t,
        b: cx_bn_t,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_pow(
        r: cx_bn_t,
        a: cx_bn_t,
        e: *const u8,
        e_len: u32,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_pow_bn(
        r: cx_bn_t,
        a: cx_bn_t,
        e: cx_bn_t,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_mont_invert_nprime(r: cx_bn_t, a: cx_bn_t, ctx: *const cx_bn_mont_ctx_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_is_prime(n: cx_bn_t, prime: *mut bool) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_next_prime(n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_rng(r: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_bn_gf2_n_mul(
        bn_r: cx_bn_t,
        bn_a: cx_bn_t,
        bn_b: cx_bn_t,
        bn_n: cx_bn_t,
        bn_h: cx_bn_t,
    ) -> cx_err_t;
}
pub const CX_CURVE_NONE: cx_curve_e = 0;
pub const CX_CURVE_WEIERSTRASS_START: cx_curve_e = 32;
pub const CX_CURVE_SECP256K1: cx_curve_e = 33;
pub const CX_CURVE_SECP256R1: cx_curve_e = 34;
pub const CX_CURVE_SECP384R1: cx_curve_e = 35;
pub const CX_CURVE_SECP521R1: cx_curve_e = 36;
pub const CX_CURVE_BrainPoolP256T1: cx_curve_e = 49;
pub const CX_CURVE_BrainPoolP256R1: cx_curve_e = 50;
pub const CX_CURVE_BrainPoolP320T1: cx_curve_e = 51;
pub const CX_CURVE_BrainPoolP320R1: cx_curve_e = 52;
pub const CX_CURVE_BrainPoolP384T1: cx_curve_e = 53;
pub const CX_CURVE_BrainPoolP384R1: cx_curve_e = 54;
pub const CX_CURVE_BrainPoolP512T1: cx_curve_e = 55;
pub const CX_CURVE_BrainPoolP512R1: cx_curve_e = 56;
pub const CX_CURVE_BLS12_381_G1: cx_curve_e = 57;
pub const CX_CURVE_FRP256V1: cx_curve_e = 65;
pub const CX_CURVE_Stark256: cx_curve_e = 81;
pub const CX_CURVE_WEIERSTRASS_END: cx_curve_e = 111;
pub const CX_CURVE_TWISTED_EDWARDS_START: cx_curve_e = 112;
pub const CX_CURVE_Ed25519: cx_curve_e = 113;
pub const CX_CURVE_Ed448: cx_curve_e = 114;
pub const CX_CURVE_TWISTED_EDWARDS_END: cx_curve_e = 127;
pub const CX_CURVE_MONTGOMERY_START: cx_curve_e = 128;
pub const CX_CURVE_Curve25519: cx_curve_e = 129;
pub const CX_CURVE_Curve448: cx_curve_e = 130;
pub const CX_CURVE_MONTGOMERY_END: cx_curve_e = 143;
pub type cx_curve_e = ::core::ffi::c_uchar;
pub use self::cx_curve_e as cx_curve_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_weierstrass_s {
    pub curve: cx_curve_t,
    pub bit_size: ::core::ffi::c_uint,
    pub length: ::core::ffi::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_weierstrass_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_curve_weierstrass_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_curve_weierstrass_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_weierstrass_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_weierstrass_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_weierstrass_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gy) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_weierstrass_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_curve_weierstrass_t = cx_curve_weierstrass_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_twisted_edwards_s {
    pub curve: cx_curve_t,
    pub bit_size: ::core::ffi::c_uint,
    pub length: ::core::ffi::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_twisted_edwards_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_curve_twisted_edwards_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_curve_twisted_edwards_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_twisted_edwards_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_twisted_edwards_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_twisted_edwards_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gy) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_twisted_edwards_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_curve_twisted_edwards_t = cx_curve_twisted_edwards_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_montgomery_s {
    pub curve: cx_curve_t,
    pub bit_size: ::core::ffi::c_uint,
    pub length: ::core::ffi::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_montgomery_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_curve_montgomery_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_curve_montgomery_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_montgomery_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_montgomery_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_montgomery_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gy) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_montgomery_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_curve_montgomery_t = cx_curve_montgomery_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_domain_s {
    pub curve: cx_curve_t,
    pub bit_size: ::core::ffi::c_uint,
    pub length: ::core::ffi::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_domain_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_curve_domain_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_curve_domain_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_domain_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_domain_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_domain_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gy) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_domain_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_curve_domain_t = cx_curve_domain_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ec_point_s {
    pub curve: cx_curve_t,
    pub x: cx_bn_t,
    pub y: cx_bn_t,
    pub z: cx_bn_t,
}
#[test]
fn bindgen_test_layout_cx_ec_point_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ec_point_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ec_point_s>(),
        16usize,
        concat!("Size of: ", stringify!(cx_ec_point_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ec_point_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ec_point_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(z)
        )
    );
}
impl Default for cx_ec_point_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_ecpoint_t = cx_ec_point_s;
pub const CX_CURVE_PARAM_NONE: cx_curve_dom_param_s = 0;
pub const CX_CURVE_PARAM_A: cx_curve_dom_param_s = 1;
pub const CX_CURVE_PARAM_B: cx_curve_dom_param_s = 2;
pub const CX_CURVE_PARAM_Field: cx_curve_dom_param_s = 3;
pub const CX_CURVE_PARAM_Gx: cx_curve_dom_param_s = 4;
pub const CX_CURVE_PARAM_Gy: cx_curve_dom_param_s = 5;
pub const CX_CURVE_PARAM_Order: cx_curve_dom_param_s = 6;
pub const CX_CURVE_PARAM_Cofactor: cx_curve_dom_param_s = 7;
pub type cx_curve_dom_param_s = ::core::ffi::c_uchar;
pub use self::cx_curve_dom_param_s as cx_curve_dom_param_t;
extern "C" {
    pub fn cx_ecdomain_size(curve: cx_curve_t, length: *mut usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecdomain_parameters_length(cv: cx_curve_t, length: *mut usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecdomain_parameter(
        cv: cx_curve_t,
        id: cx_curve_dom_param_t,
        p: *mut u8,
        p_len: u32,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecdomain_parameter_bn(
        cv: cx_curve_t,
        id: cx_curve_dom_param_t,
        p: cx_bn_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecdomain_generator(cv: cx_curve_t, Gx: *mut u8, Gy: *mut u8, len: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecdomain_generator_bn(cv: cx_curve_t, P: *mut cx_ecpoint_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_alloc(P: *mut cx_ecpoint_t, cv: cx_curve_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_destroy(P: *mut cx_ecpoint_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_init(
        P: *mut cx_ecpoint_t,
        x: *const u8,
        x_len: usize,
        y: *const u8,
        y_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_init_bn(P: *mut cx_ecpoint_t, x: cx_bn_t, y: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_export(
        P: *const cx_ecpoint_t,
        x: *mut u8,
        x_len: usize,
        y: *mut u8,
        y_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_export_bn(
        P: *const cx_ecpoint_t,
        x: *mut cx_bn_t,
        y: *mut cx_bn_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_compress(
        P: *const cx_ecpoint_t,
        xy_compressed: *mut u8,
        xy_compressed_len: usize,
        sign: *mut u32,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_decompress(
        P: *mut cx_ecpoint_t,
        xy_compressed: *const u8,
        xy_compressed_len: usize,
        sign: u32,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_add(
        R: *mut cx_ecpoint_t,
        P: *const cx_ecpoint_t,
        Q: *const cx_ecpoint_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_neg(P: *mut cx_ecpoint_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_rnd_scalarmul(P: *mut cx_ecpoint_t, k: *const u8, k_len: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_rnd_scalarmul_bn(P: *mut cx_ecpoint_t, bn_k: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_rnd_fixed_scalarmul(
        P: *mut cx_ecpoint_t,
        k: *const u8,
        k_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_scalarmul(P: *mut cx_ecpoint_t, k: *const u8, k_len: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_scalarmul_bn(P: *mut cx_ecpoint_t, bn_k: cx_bn_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_double_scalarmul(
        R: *mut cx_ecpoint_t,
        P: *mut cx_ecpoint_t,
        Q: *mut cx_ecpoint_t,
        k: *const u8,
        k_len: usize,
        r: *const u8,
        r_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_double_scalarmul_bn(
        R: *mut cx_ecpoint_t,
        P: *mut cx_ecpoint_t,
        Q: *mut cx_ecpoint_t,
        bn_k: cx_bn_t,
        bn_r: cx_bn_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_cmp(
        P: *const cx_ecpoint_t,
        Q: *const cx_ecpoint_t,
        is_equal: *mut bool,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_is_on_curve(R: *const cx_ecpoint_t, is_on_curve: *mut bool) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_is_at_infinity(R: *const cx_ecpoint_t, is_at_infinity: *mut bool)
        -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_x25519(bn_u: cx_bn_t, k: *const u8, k_len: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecpoint_x448(bn_u: cx_bn_t, k: *const u8, k_len: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_crc32_hw(buf: *const ::core::ffi::c_void, len: usize) -> u32;
}
extern "C" {
    pub fn cx_trng_get_random_data(buf: *mut u8, size: usize);
}
extern "C" {
    pub fn cx_trng_selftest();
}
extern "C" {
    pub fn cx_trng_init();
}
pub type uint64bits_t = u64;
pub const ERR_GEN_ID_01: generic_identifiers = 1;
pub const ERR_GEN_ID_02: generic_identifiers = 2;
pub const ERR_GEN_ID_03: generic_identifiers = 3;
pub const ERR_GEN_ID_04: generic_identifiers = 4;
pub const ERR_GEN_ID_05: generic_identifiers = 5;
pub const ERR_GEN_ID_06: generic_identifiers = 6;
pub const ERR_GEN_ID_07: generic_identifiers = 7;
pub const ERR_GEN_ID_08: generic_identifiers = 8;
pub const ERR_GEN_ID_09: generic_identifiers = 9;
pub const ERR_GEN_ID_0A: generic_identifiers = 10;
pub const ERR_GEN_ID_0B: generic_identifiers = 11;
pub const ERR_GEN_ID_0C: generic_identifiers = 12;
pub const ERR_GEN_ID_0D: generic_identifiers = 13;
pub const ERR_GEN_ID_0E: generic_identifiers = 14;
pub const ERR_GEN_ID_0F: generic_identifiers = 15;
pub const ERR_GEN_ID_10: generic_identifiers = 16;
pub const ERR_GEN_ID_11: generic_identifiers = 17;
pub const ERR_GEN_ID_12: generic_identifiers = 18;
pub const ERR_GEN_ID_13: generic_identifiers = 19;
pub const ERR_GEN_ID_14: generic_identifiers = 20;
pub const ERR_GEN_ID_15: generic_identifiers = 21;
pub const ERR_GEN_ID_16: generic_identifiers = 22;
pub const ERR_GEN_ID_17: generic_identifiers = 23;
pub const ERR_GEN_ID_18: generic_identifiers = 24;
pub const ERR_GEN_ID_19: generic_identifiers = 25;
pub const ERR_GEN_ID_1A: generic_identifiers = 26;
pub const ERR_GEN_ID_1B: generic_identifiers = 27;
pub const ERR_GEN_ID_1C: generic_identifiers = 28;
pub const ERR_GEN_ID_1D: generic_identifiers = 29;
pub const ERR_GEN_ID_1E: generic_identifiers = 30;
pub const ERR_GEN_ID_1F: generic_identifiers = 31;
pub const ERR_GEN_ID_20: generic_identifiers = 32;
pub const ERR_GEN_ID_21: generic_identifiers = 33;
pub const ERR_GEN_ID_22: generic_identifiers = 34;
pub const ERR_GEN_ID_23: generic_identifiers = 35;
pub const ERR_GEN_ID_24: generic_identifiers = 36;
pub const ERR_GEN_ID_25: generic_identifiers = 37;
pub const ERR_GEN_ID_26: generic_identifiers = 38;
pub const ERR_GEN_ID_27: generic_identifiers = 39;
pub const ERR_GEN_ID_28: generic_identifiers = 40;
pub const ERR_GEN_ID_29: generic_identifiers = 41;
pub const ERR_GEN_ID_2A: generic_identifiers = 42;
pub const ERR_GEN_ID_2B: generic_identifiers = 43;
pub const ERR_GEN_ID_2C: generic_identifiers = 44;
pub const ERR_GEN_ID_2D: generic_identifiers = 45;
pub const ERR_GEN_ID_2E: generic_identifiers = 46;
pub const ERR_GEN_ID_2F: generic_identifiers = 47;
pub const ERR_GEN_ID_30: generic_identifiers = 48;
pub const ERR_GEN_ID_31: generic_identifiers = 49;
pub const ERR_GEN_ID_32: generic_identifiers = 50;
pub const ERR_GEN_ID_33: generic_identifiers = 51;
pub const ERR_GEN_ID_34: generic_identifiers = 52;
pub const ERR_GEN_ID_35: generic_identifiers = 53;
pub const ERR_GEN_ID_36: generic_identifiers = 54;
pub const ERR_GEN_ID_37: generic_identifiers = 55;
pub const ERR_GEN_ID_38: generic_identifiers = 56;
pub const ERR_GEN_ID_39: generic_identifiers = 57;
pub const ERR_GEN_ID_3A: generic_identifiers = 58;
pub const ERR_GEN_ID_3B: generic_identifiers = 59;
pub const ERR_GEN_ID_3C: generic_identifiers = 60;
pub const ERR_GEN_ID_3D: generic_identifiers = 61;
pub type generic_identifiers = ::core::ffi::c_uchar;
pub type bolos_err_t = u32;
pub type exception_t = ::core::ffi::c_ushort;
pub type try_context_t = try_context_s;
pub type jmp_buf = [::core::ffi::c_uint; 10usize];
extern "C" {
    pub fn longjmp(__jmpb: *mut ::core::ffi::c_uint, __retval: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn setjmp(__jmpb: *mut ::core::ffi::c_uint) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct try_context_s {
    pub jmp_buf: jmp_buf,
    pub previous: *mut try_context_t,
    pub ex: exception_t,
}
#[test]
fn bindgen_test_layout_try_context_s() {
    const UNINIT: ::core::mem::MaybeUninit<try_context_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<try_context_s>(),
        48usize,
        concat!("Size of: ", stringify!(try_context_s))
    );
    assert_eq!(
        ::core::mem::align_of::<try_context_s>(),
        4usize,
        concat!("Alignment of ", stringify!(try_context_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(try_context_s),
            "::",
            stringify!(jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).previous) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(try_context_s),
            "::",
            stringify!(previous)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ex) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(try_context_s),
            "::",
            stringify!(ex)
        )
    );
}
impl Default for try_context_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn try_context_get() -> *mut try_context_t;
}
extern "C" {
    pub fn try_context_set(context: *mut try_context_t) -> *mut try_context_t;
}
extern "C" {
    pub fn os_longjmp(exception: ::core::ffi::c_uint) -> !;
}
extern "C" {
    pub fn os_parse_bertlv(
        mem: *mut ::core::ffi::c_uchar,
        mem_len: ::core::ffi::c_uint,
        tlv_instance_offset: *mut ::core::ffi::c_uint,
        tag: ::core::ffi::c_uint,
        offset: ::core::ffi::c_uint,
        buffer: *mut *mut ::core::ffi::c_void,
        maxlength: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
pub const CX_NONE: cx_md_e = 0;
pub const CX_RIPEMD160: cx_md_e = 1;
pub const CX_SHA224: cx_md_e = 2;
pub const CX_SHA256: cx_md_e = 3;
pub const CX_SHA384: cx_md_e = 4;
pub const CX_SHA512: cx_md_e = 5;
pub const CX_KECCAK: cx_md_e = 6;
pub const CX_SHA3: cx_md_e = 7;
pub const DEPRECATED_0: cx_md_e = 8;
pub const CX_BLAKE2B: cx_md_e = 9;
pub const CX_SHAKE128: cx_md_e = 10;
pub const CX_SHAKE256: cx_md_e = 11;
pub const CX_SHA3_256: cx_md_e = 12;
pub const CX_SHA3_512: cx_md_e = 13;
pub type cx_md_e = ::core::ffi::c_uchar;
pub use self::cx_md_e as cx_md_t;
pub type cx_hash_t = cx_hash_header_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hash_info_t {
    pub md_type: cx_md_t,
    pub output_size: usize,
    pub block_size: usize,
    pub ctx_size: usize,
    pub init_func: ::core::option::Option<unsafe extern "C" fn(ctx: *mut cx_hash_t) -> cx_err_t>,
    pub update_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cx_hash_t, data: *const u8, len: usize) -> cx_err_t,
    >,
    pub finish_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cx_hash_t, digest: *mut u8) -> cx_err_t,
    >,
    pub init_ex_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cx_hash_t, output_size: usize) -> cx_err_t,
    >,
    pub output_size_func:
        ::core::option::Option<unsafe extern "C" fn(ctx: *const cx_hash_t) -> usize>,
}
#[test]
fn bindgen_test_layout_cx_hash_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hash_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hash_info_t>(),
        36usize,
        concat!("Size of: ", stringify!(cx_hash_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hash_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hash_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).md_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(md_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(ctx_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(init_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).update_func) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(update_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).finish_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(finish_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_ex_func) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(init_ex_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_size_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(output_size_func)
        )
    );
}
impl Default for cx_hash_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hash_header_s {
    pub info: *const cx_hash_info_t,
    pub counter: u32,
}
#[test]
fn bindgen_test_layout_cx_hash_header_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hash_header_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hash_header_s>(),
        8usize,
        concat!("Size of: ", stringify!(cx_hash_header_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hash_header_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hash_header_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_header_s),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_header_s),
            "::",
            stringify!(counter)
        )
    );
}
impl Default for cx_hash_header_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn cx_hash_get_size(ctx: *const cx_hash_t) -> usize;
}
extern "C" {
    pub fn cx_hash_no_throw(
        hash: *mut cx_hash_t,
        mode: u32,
        in_: *const u8,
        len: usize,
        out: *mut u8,
        out_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_hash_init(hash: *mut cx_hash_t, hash_id: cx_md_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_hash_init_ex(hash: *mut cx_hash_t, hash_id: cx_md_t, output_size: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_hash_update(hash: *mut cx_hash_t, in_: *const u8, in_len: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_hash_final(hash: *mut cx_hash_t, digest: *mut u8) -> cx_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ripemd160_s {
    pub header: cx_hash_header_s,
    pub blen: usize,
    pub block: [u8; 64usize],
    pub acc: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_cx_ripemd160_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ripemd160_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ripemd160_s>(),
        96usize,
        concat!("Size of: ", stringify!(cx_ripemd160_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ripemd160_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ripemd160_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acc) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_ripemd160_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_ripemd160_t = cx_ripemd160_s;
extern "C" {
    pub fn cx_ripemd160_init_no_throw(hash: *mut cx_ripemd160_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_hash_ripemd160(in_: *const u8, in_len: usize, out: *mut u8, out_len: usize) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_sha256_s {
    pub header: cx_hash_header_s,
    pub blen: usize,
    pub block: [u8; 64usize],
    pub acc: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_cx_sha256_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_sha256_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_sha256_s>(),
        108usize,
        concat!("Size of: ", stringify!(cx_sha256_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha256_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_sha256_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acc) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_sha256_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_sha256_t = cx_sha256_s;
extern "C" {
    pub fn cx_sha224_init_no_throw(hash: *mut cx_sha256_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_sha256_init_no_throw(hash: *mut cx_sha256_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_hash_sha256(in_: *const u8, len: usize, out: *mut u8, out_len: usize) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_sha512_s {
    pub header: cx_hash_header_s,
    pub blen: usize,
    pub block: [u8; 128usize],
    pub acc: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_cx_sha512_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_sha512_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_sha512_s>(),
        204usize,
        concat!("Size of: ", stringify!(cx_sha512_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha512_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_sha512_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acc) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_sha512_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_sha512_t = cx_sha512_s;
extern "C" {
    pub fn cx_sha384_init_no_throw(hash: *mut cx_sha512_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_sha512_init_no_throw(hash: *mut cx_sha512_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_hash_sha512(in_: *const u8, in_len: usize, out: *mut u8, out_len: usize) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_sha3_s {
    pub header: cx_hash_header_s,
    pub output_size: usize,
    pub block_size: usize,
    pub blen: usize,
    pub block: [u8; 200usize],
    pub acc: [uint64bits_t; 25usize],
}
#[test]
fn bindgen_test_layout_cx_sha3_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_sha3_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_sha3_s>(),
        424usize,
        concat!("Size of: ", stringify!(cx_sha3_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha3_s>(),
        8usize,
        concat!("Alignment of ", stringify!(cx_sha3_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acc) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_sha3_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_sha3_t = cx_sha3_s;
extern "C" {
    pub fn cx_sha3_init_no_throw(hash: *mut cx_sha3_t, size: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_keccak_init_no_throw(hash: *mut cx_sha3_t, size: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_shake128_init_no_throw(hash: *mut cx_sha3_t, out_size: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_shake256_init_no_throw(hash: *mut cx_sha3_t, out_size: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_sha3_xof_init_no_throw(
        hash: *mut cx_sha3_t,
        size: usize,
        out_length: usize,
    ) -> cx_err_t;
}
pub const BLAKE2B_BLOCKBYTES: blake2b_constant = 128;
pub const BLAKE2B_OUTBYTES: blake2b_constant = 64;
pub const BLAKE2B_KEYBYTES: blake2b_constant = 64;
pub const BLAKE2B_SALTBYTES: blake2b_constant = 16;
pub const BLAKE2B_PERSONALBYTES: blake2b_constant = 16;
pub type blake2b_constant = ::core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blake2b_state__ {
    pub h: [u64; 8usize],
    pub t: [u64; 2usize],
    pub f: [u64; 2usize],
    pub buf: [u8; 128usize],
    pub buflen: usize,
    pub outlen: usize,
    pub last_node: u8,
}
#[test]
fn bindgen_test_layout_blake2b_state__() {
    const UNINIT: ::core::mem::MaybeUninit<blake2b_state__> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<blake2b_state__>(),
        240usize,
        concat!("Size of: ", stringify!(blake2b_state__))
    );
    assert_eq!(
        ::core::mem::align_of::<blake2b_state__>(),
        8usize,
        concat!("Alignment of ", stringify!(blake2b_state__))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buflen) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(buflen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outlen) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(outlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_node) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(last_node)
        )
    );
}
impl Default for blake2b_state__ {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type blake2b_state = blake2b_state__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_blake2b_s {
    pub header: cx_hash_header_s,
    pub output_size: usize,
    pub ctx: blake2b_state__,
}
#[test]
fn bindgen_test_layout_cx_blake2b_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_blake2b_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_blake2b_s>(),
        256usize,
        concat!("Size of: ", stringify!(cx_blake2b_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_blake2b_s>(),
        8usize,
        concat!("Alignment of ", stringify!(cx_blake2b_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for cx_blake2b_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_blake2b_t = cx_blake2b_s;
extern "C" {
    pub fn cx_blake2b_init_no_throw(hash: *mut cx_blake2b_t, out_len: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_blake2b_init2_no_throw(
        hash: *mut cx_blake2b_t,
        out_len: usize,
        salt: *mut u8,
        salt_len: usize,
        perso: *mut u8,
        perso_len: usize,
    ) -> cx_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hmac_t {
    pub key: [u8; 128usize],
    pub hash_ctx: cx_hash_t,
}
#[test]
fn bindgen_test_layout_cx_hmac_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hmac_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_t>(),
        136usize,
        concat!("Size of: ", stringify!(cx_hmac_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_ctx) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_t),
            "::",
            stringify!(hash_ctx)
        )
    );
}
impl Default for cx_hmac_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hmac_ripemd160_t {
    pub key: [u8; 128usize],
    pub hash_ctx: cx_ripemd160_t,
}
#[test]
fn bindgen_test_layout_cx_hmac_ripemd160_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hmac_ripemd160_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_ripemd160_t>(),
        224usize,
        concat!("Size of: ", stringify!(cx_hmac_ripemd160_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_ripemd160_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_ripemd160_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_ripemd160_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_ctx) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_ripemd160_t),
            "::",
            stringify!(hash_ctx)
        )
    );
}
impl Default for cx_hmac_ripemd160_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn cx_hmac_ripemd160_init_no_throw(
        hmac: *mut cx_hmac_ripemd160_t,
        key: *const u8,
        key_len: usize,
    ) -> cx_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hmac_sha256_t {
    pub key: [u8; 128usize],
    pub hash_ctx: cx_sha256_t,
}
#[test]
fn bindgen_test_layout_cx_hmac_sha256_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hmac_sha256_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_sha256_t>(),
        236usize,
        concat!("Size of: ", stringify!(cx_hmac_sha256_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_sha256_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_sha256_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha256_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_ctx) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha256_t),
            "::",
            stringify!(hash_ctx)
        )
    );
}
impl Default for cx_hmac_sha256_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn cx_hmac_sha224_init(
        hmac: *mut cx_hmac_sha256_t,
        key: *const u8,
        key_len: ::core::ffi::c_uint,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_hmac_sha256_init_no_throw(
        hmac: *mut cx_hmac_sha256_t,
        key: *const u8,
        key_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_hmac_sha256(
        key: *const u8,
        key_len: usize,
        in_: *const u8,
        len: usize,
        mac: *mut u8,
        mac_len: usize,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hmac_sha512_t {
    pub key: [u8; 128usize],
    pub hash_ctx: cx_sha512_t,
}
#[test]
fn bindgen_test_layout_cx_hmac_sha512_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hmac_sha512_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_sha512_t>(),
        332usize,
        concat!("Size of: ", stringify!(cx_hmac_sha512_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_sha512_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_sha512_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha512_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_ctx) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha512_t),
            "::",
            stringify!(hash_ctx)
        )
    );
}
impl Default for cx_hmac_sha512_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn cx_hmac_sha384_init(
        hmac: *mut cx_hmac_sha512_t,
        key: *const u8,
        key_len: ::core::ffi::c_uint,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_hmac_sha512_init_no_throw(
        hmac: *mut cx_hmac_sha512_t,
        key: *const u8,
        key_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_hmac_sha512(
        key: *const u8,
        key_len: usize,
        in_: *const u8,
        len: usize,
        mac: *mut u8,
        mac_len: usize,
    ) -> usize;
}
extern "C" {
    pub fn cx_hmac_no_throw(
        hmac: *mut cx_hmac_t,
        mode: u32,
        in_: *const u8,
        len: usize,
        mac: *mut u8,
        mac_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_hmac_init(
        hmac: *mut cx_hmac_t,
        hash_id: cx_md_t,
        key: *const u8,
        key_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_hmac_update(hmac: *mut cx_hmac_t, in_: *const u8, in_len: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_hmac_final(ctx: *mut cx_hmac_t, out: *mut u8, out_len: *mut usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_pbkdf2_no_throw(
        md_type: cx_md_t,
        password: *const u8,
        passwordlen: usize,
        salt: *mut u8,
        saltlen: usize,
        iterations: u32,
        out: *mut u8,
        outLength: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_rng_no_throw(buffer: *mut u8, len: usize);
}
pub type cx_rng_u32_range_randfunc_t = ::core::option::Option<unsafe extern "C" fn() -> u32>;
extern "C" {
    pub fn cx_rng_u32_range_func(a: u32, b: u32, randfunc: cx_rng_u32_range_randfunc_t) -> u32;
}
extern "C" {
    pub fn cx_rng_rfc6979(
        hash_id: cx_md_t,
        x: *const u8,
        x_len: usize,
        h1: *const u8,
        h1_len: usize,
        q: *const u8,
        q_len: usize,
        out: *mut u8,
        out_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_cmp_no_throw(
        a: *const u8,
        b: *const u8,
        length: usize,
        diff: *mut ::core::ffi::c_int,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_add_no_throw(r: *mut u8, a: *const u8, b: *const u8, len: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_sub_no_throw(r: *mut u8, a: *const u8, b: *const u8, len: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_mult_no_throw(r: *mut u8, a: *const u8, b: *const u8, len: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_addm_no_throw(
        r: *mut u8,
        a: *const u8,
        b: *const u8,
        m: *const u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_subm_no_throw(
        r: *mut u8,
        a: *const u8,
        b: *const u8,
        m: *const u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_multm_no_throw(
        r: *mut u8,
        a: *const u8,
        b: *const u8,
        m: *const u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_modm_no_throw(v: *mut u8, len_v: usize, m: *const u8, len_m: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_powm_no_throw(
        r: *mut u8,
        a: *const u8,
        e: *const u8,
        len_e: usize,
        m: *const u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_invprimem_no_throw(
        r: *mut u8,
        a: *const u8,
        m: *const u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_invintm_no_throw(r: *mut u8, a: u32, m: *const u8, len: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_is_prime_no_throw(r: *const u8, len: usize, prime: *mut bool) -> cx_err_t;
}
extern "C" {
    pub fn cx_math_next_prime_no_throw(r: *mut u8, len: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_init_key_no_throw(
        rawkey: *const u8,
        key_len: usize,
        key: *mut cx_aes_key_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_iv_no_throw(
        key: *const cx_aes_key_t,
        mode: u32,
        iv: *const u8,
        iv_len: usize,
        in_: *const u8,
        in_len: usize,
        out: *mut u8,
        out_len: *mut usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_no_throw(
        key: *const cx_aes_key_t,
        mode: u32,
        in_: *const u8,
        in_len: usize,
        out: *mut u8,
        out_len: *mut usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_enc_block(
        key: *const cx_aes_key_t,
        inblock: *const u8,
        outblock: *mut u8,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_dec_block(
        key: *const cx_aes_key_t,
        inblock: *const u8,
        outblock: *mut u8,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_des_init_key_no_throw(
        rawkey: *const u8,
        key_len: usize,
        key: *mut cx_des_key_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_des_iv_no_throw(
        key: *const cx_des_key_t,
        mode: u32,
        iv: *const u8,
        iv_len: usize,
        in_: *const u8,
        in_len: usize,
        out: *mut u8,
        out_len: *mut usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_des_no_throw(
        key: *const cx_des_key_t,
        mode: u32,
        in_: *const u8,
        in_len: usize,
        out: *mut u8,
        out_len: *mut usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_des_enc_block(
        key: *const cx_des_key_t,
        inblock: *const u8,
        outblock: *mut u8,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_des_dec_block(
        key: *const cx_des_key_t,
        inblock: *const u8,
        outblock: *mut u8,
    ) -> cx_err_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_cmac_context_t {
    pub state: [u8; 16usize],
    pub unprocessed_block: [u8; 16usize],
    pub unprocessed_len: usize,
}
#[test]
fn bindgen_test_layout_cx_cmac_context_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_cmac_context_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_cmac_context_t>(),
        36usize,
        concat!("Size of: ", stringify!(cx_cmac_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_cmac_context_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_cmac_context_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cmac_context_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unprocessed_block) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cmac_context_t),
            "::",
            stringify!(unprocessed_block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unprocessed_len) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cmac_context_t),
            "::",
            stringify!(unprocessed_len)
        )
    );
}
pub const CX_CIPHER_NONE: cx_cipher_id_t = 0;
pub const CX_CIPHER_AES_128: cx_cipher_id_t = 1;
pub const CX_CIPHER_AES_192: cx_cipher_id_t = 2;
pub const CX_CIPHER_AES_256: cx_cipher_id_t = 3;
pub const CX_CIPHER_DES_64: cx_cipher_id_t = 4;
pub const CX_CIPHER_3DES_128: cx_cipher_id_t = 5;
pub const CX_CIPHER_3DES_192: cx_cipher_id_t = 6;
pub type cx_cipher_id_t = ::core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cipher_key_t {
    pub size: ::core::ffi::c_uint,
    pub keys: [::core::ffi::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_cipher_key_t() {
    const UNINIT: ::core::mem::MaybeUninit<cipher_key_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cipher_key_t>(),
        36usize,
        concat!("Size of: ", stringify!(cipher_key_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cipher_key_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cipher_key_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_key_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_key_t),
            "::",
            stringify!(keys)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_cipher_base_t {
    pub enc_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx_key: *const cipher_key_t,
            in_block: *const u8,
            out_block: *mut u8,
        ) -> cx_err_t,
    >,
    pub dec_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx_key: *const cipher_key_t,
            in_block: *const u8,
            out_block: *mut u8,
        ) -> cx_err_t,
    >,
    pub ctr_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx_key: *const cipher_key_t,
            len: usize,
            nc_off: *mut usize,
            nonce_counter: *mut u8,
            stream_block: *mut u8,
            input: *const u8,
            output: *mut u8,
        ) -> cx_err_t,
    >,
    pub setkey_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx_key: *const cipher_key_t,
            operation: u32,
            key: *const u8,
            key_bitlen: u32,
        ) -> cx_err_t,
    >,
    pub ctx_reset: ::core::option::Option<unsafe extern "C" fn() -> cx_err_t>,
}
#[test]
fn bindgen_test_layout_cx_cipher_base_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_cipher_base_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_cipher_base_t>(),
        20usize,
        concat!("Size of: ", stringify!(cx_cipher_base_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_cipher_base_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_cipher_base_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enc_func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_base_t),
            "::",
            stringify!(enc_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dec_func) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_base_t),
            "::",
            stringify!(dec_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctr_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_base_t),
            "::",
            stringify!(ctr_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setkey_func) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_base_t),
            "::",
            stringify!(setkey_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx_reset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_base_t),
            "::",
            stringify!(ctx_reset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_cipher_info_t {
    pub key_bitlen: u32,
    pub iv_size: u32,
    pub block_size: u32,
    pub base: *const cx_cipher_base_t,
}
#[test]
fn bindgen_test_layout_cx_cipher_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_cipher_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_cipher_info_t>(),
        16usize,
        concat!("Size of: ", stringify!(cx_cipher_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_cipher_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_cipher_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_bitlen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_info_t),
            "::",
            stringify!(key_bitlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_info_t),
            "::",
            stringify!(iv_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_info_t),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_info_t),
            "::",
            stringify!(base)
        )
    );
}
impl Default for cx_cipher_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_cipher_context_t {
    pub cipher_info: *const cx_cipher_info_t,
    pub key_bitlen: u32,
    pub operation: u32,
    pub add_padding: ::core::option::Option<
        unsafe extern "C" fn(output: *mut u8, out_len: usize, data_len: usize),
    >,
    pub get_padding: ::core::option::Option<
        unsafe extern "C" fn(input: *mut u8, in_len: usize, data_len: *mut usize) -> cx_err_t,
    >,
    pub unprocessed_data: [u8; 16usize],
    pub unprocessed_len: usize,
    pub iv: [u8; 16usize],
    pub iv_size: usize,
    pub mode: u32,
    pub sig: [u8; 16usize],
    pub cipher_key: *const cipher_key_t,
    pub cmac_ctx: *mut cx_cmac_context_t,
}
#[test]
fn bindgen_test_layout_cx_cipher_context_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_cipher_context_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_cipher_context_t>(),
        88usize,
        concat!("Size of: ", stringify!(cx_cipher_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_cipher_context_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_cipher_context_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(cipher_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_bitlen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(key_bitlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_padding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(add_padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_padding) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(get_padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unprocessed_data) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(unprocessed_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unprocessed_len) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(unprocessed_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(iv_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_key) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(cipher_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmac_ctx) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(cmac_ctx)
        )
    );
}
impl Default for cx_cipher_context_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn cx_cipher_init(ctx: *mut cx_cipher_context_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_cipher_setup(
        ctx: *mut cx_cipher_context_t,
        type_: cx_cipher_id_t,
        mode: u32,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_cipher_setkey(
        ctx: *mut cx_cipher_context_t,
        key: *const u8,
        key_bitlen: u32,
        operation: u32,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_cipher_setiv(ctx: *mut cx_cipher_context_t, iv: *const u8, iv_len: usize)
        -> cx_err_t;
}
extern "C" {
    pub fn cx_cipher_set_padding(ctx: *mut cx_cipher_context_t, padding: u32) -> cx_err_t;
}
extern "C" {
    pub fn cx_cipher_update(
        ctx: *mut cx_cipher_context_t,
        input: *const u8,
        in_len: usize,
        output: *mut u8,
        out_len: *mut usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_cipher_finish(
        ctx: *mut cx_cipher_context_t,
        output: *mut u8,
        out_len: *mut usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_cipher_enc_dec(
        ctx: *mut cx_cipher_context_t,
        iv: *const u8,
        iv_len: usize,
        input: *const u8,
        in_len: usize,
        output: *mut u8,
        out_len: *mut usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_cipher_reset(ctx: *mut cx_cipher_context_t);
}
extern "C" {
    pub fn add_one_and_zeros_padding(output: *mut u8, out_len: usize, data_len: usize);
}
extern "C" {
    pub fn cx_cmac_start(
        ctx: *mut cx_cipher_context_t,
        key: *const u8,
        key_bitlen: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_cmac_update(
        ctx: *mut cx_cipher_context_t,
        input: *const u8,
        in_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_cmac_finish(ctx: *mut cx_cipher_context_t, output: *mut u8) -> cx_err_t;
}
extern "C" {
    pub fn cx_cmac(
        type_: cx_cipher_id_t,
        key: *const u8,
        key_bitlen: usize,
        input: *const u8,
        in_len: usize,
        output: *mut u8,
    ) -> cx_err_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_aes_gcm_context_t {
    pub key: cx_aes_key_t,
    pub len: usize,
    pub aad_len: usize,
    pub enc_block: [u8; 16usize],
    pub J0: [u8; 16usize],
    pub processed: [u8; 16usize],
    pub hash_key: [u8; 16usize],
    pub mode: u32,
    pub flag: u8,
}
#[test]
fn bindgen_test_layout_cx_aes_gcm_context_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_aes_gcm_context_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_aes_gcm_context_t>(),
        116usize,
        concat!("Size of: ", stringify!(cx_aes_gcm_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_aes_gcm_context_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_aes_gcm_context_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_gcm_context_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_gcm_context_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aad_len) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_gcm_context_t),
            "::",
            stringify!(aad_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enc_block) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_gcm_context_t),
            "::",
            stringify!(enc_block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).J0) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_gcm_context_t),
            "::",
            stringify!(J0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).processed) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_gcm_context_t),
            "::",
            stringify!(processed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_key) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_gcm_context_t),
            "::",
            stringify!(hash_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_gcm_context_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_gcm_context_t),
            "::",
            stringify!(flag)
        )
    );
}
extern "C" {
    pub fn cx_aes_gcm_init(ctx: *mut cx_aes_gcm_context_t);
}
extern "C" {
    pub fn cx_aes_gcm_set_key(
        ctx: *mut cx_aes_gcm_context_t,
        raw_key: *const u8,
        key_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_gcm_start(
        ctx: *mut cx_aes_gcm_context_t,
        mode: u32,
        iv: *const u8,
        iv_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_gcm_update_aad(
        ctx: *mut cx_aes_gcm_context_t,
        aad: *const u8,
        aad_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_gcm_update(
        ctx: *mut cx_aes_gcm_context_t,
        in_: *const u8,
        out: *mut u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_gcm_finish(
        ctx: *mut cx_aes_gcm_context_t,
        tag: *mut u8,
        tag_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_gcm_encrypt_and_tag(
        ctx: *mut cx_aes_gcm_context_t,
        in_: *mut u8,
        len: usize,
        iv: *const u8,
        iv_len: usize,
        aad: *const u8,
        aad_len: usize,
        out: *mut u8,
        tag: *mut u8,
        tag_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_gcm_decrypt_and_auth(
        ctx: *mut cx_aes_gcm_context_t,
        in_: *mut u8,
        len: usize,
        iv: *const u8,
        iv_len: usize,
        aad: *const u8,
        aad_len: usize,
        out: *mut u8,
        tag: *const u8,
        tag_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_gcm_check_tag(
        ctx: *mut cx_aes_gcm_context_t,
        tag: *const u8,
        tag_len: usize,
    ) -> cx_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cx_aes_siv_context {
    pub key1: [u8; 32usize],
    pub key2: [u8; 32usize],
    pub key_len: usize,
    pub tag_state: [u8; 16usize],
    pub cipher_type: cx_cipher_id_t,
    pub mode: u32,
    pub cipher_ctx: *mut cx_cipher_context_t,
}
#[test]
fn bindgen_test_layout__cx_aes_siv_context() {
    const UNINIT: ::core::mem::MaybeUninit<_cx_aes_siv_context> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cx_aes_siv_context>(),
        96usize,
        concat!("Size of: ", stringify!(_cx_aes_siv_context))
    );
    assert_eq!(
        ::core::mem::align_of::<_cx_aes_siv_context>(),
        4usize,
        concat!("Alignment of ", stringify!(_cx_aes_siv_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cx_aes_siv_context),
            "::",
            stringify!(key1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_cx_aes_siv_context),
            "::",
            stringify!(key2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_len) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cx_aes_siv_context),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tag_state) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_cx_aes_siv_context),
            "::",
            stringify!(tag_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_type) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_cx_aes_siv_context),
            "::",
            stringify!(cipher_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cx_aes_siv_context),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_ctx) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_cx_aes_siv_context),
            "::",
            stringify!(cipher_ctx)
        )
    );
}
impl Default for _cx_aes_siv_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_aes_siv_context_t = _cx_aes_siv_context;
extern "C" {
    pub fn cx_aes_siv_init(ctx: *mut cx_aes_siv_context_t) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_siv_set_key(
        ctx: *mut cx_aes_siv_context_t,
        key: *const u8,
        key_bitlen: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_siv_start(
        ctx: *mut cx_aes_siv_context_t,
        mode: u32,
        iv: *const u8,
        iv_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_siv_update_aad(
        ctx: *mut cx_aes_siv_context_t,
        aad: *const u8,
        aad_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_siv_update(
        ctx: *mut cx_aes_siv_context_t,
        input: *const u8,
        output: *mut u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_siv_finish(
        ctx: *mut cx_aes_siv_context_t,
        input: *const u8,
        in_len: usize,
        tag: *mut u8,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_siv_encrypt(
        ctx: *mut cx_aes_siv_context_t,
        input: *const u8,
        in_len: usize,
        aad: *const u8,
        aad_len: usize,
        output: *mut u8,
        tag: *mut u8,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_aes_siv_decrypt(
        ctx: *mut cx_aes_siv_context_t,
        input: *const u8,
        in_len: usize,
        aad: *const u8,
        aad_len: usize,
        output: *mut u8,
        tag: *mut u8,
    ) -> cx_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_public_key_s {
    pub curve: cx_curve_t,
    pub W_len: usize,
    pub W: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_public_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_public_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_public_key_s>(),
        12usize,
        concat!("Size of: ", stringify!(cx_ecfp_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_public_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_private_key_s {
    pub curve: cx_curve_t,
    pub d_len: usize,
    pub d: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_private_key_s>(),
        12usize,
        concat!("Size of: ", stringify!(cx_ecfp_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_private_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_256_public_key_s {
    pub curve: cx_curve_t,
    pub W_len: usize,
    pub W: [u8; 65usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_256_public_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_256_public_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_256_public_key_s>(),
        76usize,
        concat!("Size of: ", stringify!(cx_ecfp_256_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_256_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_256_public_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_256_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_256_private_key_s {
    pub curve: cx_curve_t,
    pub d_len: usize,
    pub d: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_256_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_256_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_256_private_key_s>(),
        40usize,
        concat!("Size of: ", stringify!(cx_ecfp_256_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_256_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_256_private_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_256_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_256_extended_private_key_s {
    pub curve: cx_curve_t,
    pub d_len: usize,
    pub d: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_256_extended_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_256_extended_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_256_extended_private_key_s>(),
        72usize,
        concat!("Size of: ", stringify!(cx_ecfp_256_extended_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_256_extended_private_key_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cx_ecfp_256_extended_private_key_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_extended_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_extended_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_extended_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_256_extended_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_ecfp_256_public_key_t = cx_ecfp_256_public_key_s;
pub type cx_ecfp_256_private_key_t = cx_ecfp_256_private_key_s;
pub type cx_ecfp_256_extended_private_key_t = cx_ecfp_256_extended_private_key_s;
pub type cx_ecfp_public_key_t = cx_ecfp_256_public_key_s;
pub type cx_ecfp_private_key_t = cx_ecfp_256_private_key_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_384_public_key_s {
    pub curve: cx_curve_t,
    pub W_len: usize,
    pub W: [u8; 97usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_384_public_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_384_public_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_384_public_key_s>(),
        108usize,
        concat!("Size of: ", stringify!(cx_ecfp_384_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_384_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_384_public_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_384_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_384_private_key_s {
    pub curve: cx_curve_t,
    pub d_len: usize,
    pub d: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_384_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_384_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_384_private_key_s>(),
        56usize,
        concat!("Size of: ", stringify!(cx_ecfp_384_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_384_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_384_private_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_384_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_ecfp_384_private_key_t = cx_ecfp_384_private_key_s;
pub type cx_ecfp_384_public_key_t = cx_ecfp_384_public_key_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_512_public_key_s {
    pub curve: cx_curve_t,
    pub W_len: usize,
    pub W: [u8; 129usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_512_public_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_512_public_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_512_public_key_s>(),
        140usize,
        concat!("Size of: ", stringify!(cx_ecfp_512_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_512_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_512_public_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_512_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_512_private_key_s {
    pub curve: cx_curve_t,
    pub d_len: usize,
    pub d: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_512_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_512_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_512_private_key_s>(),
        72usize,
        concat!("Size of: ", stringify!(cx_ecfp_512_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_512_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_512_private_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_512_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_512_extented_private_key_s {
    pub curve: cx_curve_t,
    pub d_len: usize,
    pub d: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_512_extented_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_512_extented_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_512_extented_private_key_s>(),
        136usize,
        concat!("Size of: ", stringify!(cx_ecfp_512_extented_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_512_extented_private_key_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cx_ecfp_512_extented_private_key_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_extented_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_extented_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_extented_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_512_extented_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_ecfp_512_public_key_t = cx_ecfp_512_public_key_s;
pub type cx_ecfp_512_private_key_t = cx_ecfp_512_private_key_s;
pub type cx_ecfp_512_extented_private_key_t = cx_ecfp_512_extented_private_key_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_640_public_key_s {
    pub curve: cx_curve_t,
    pub W_len: usize,
    pub W: [u8; 161usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_640_public_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_640_public_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_640_public_key_s>(),
        172usize,
        concat!("Size of: ", stringify!(cx_ecfp_640_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_640_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_640_public_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_640_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_640_private_key_s {
    pub curve: cx_curve_t,
    pub d_len: usize,
    pub d: [u8; 80usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_640_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_640_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_640_private_key_s>(),
        88usize,
        concat!("Size of: ", stringify!(cx_ecfp_640_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_640_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_640_private_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_640_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cx_ecfp_640_public_key_t = cx_ecfp_640_public_key_s;
pub type cx_ecfp_640_private_key_t = cx_ecfp_640_private_key_s;
extern "C" {
    pub fn cx_ecfp_add_point_no_throw(
        curve: cx_curve_t,
        R: *mut u8,
        P: *const u8,
        Q: *const u8,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecfp_scalar_mult_no_throw(
        curve: cx_curve_t,
        P: *mut u8,
        k: *const u8,
        k_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecfp_init_public_key_no_throw(
        curve: cx_curve_t,
        rawkey: *const u8,
        key_len: usize,
        key: *mut cx_ecfp_public_key_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecfp_init_private_key_no_throw(
        curve: cx_curve_t,
        rawkey: *const u8,
        key_len: usize,
        pvkey: *mut cx_ecfp_private_key_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecfp_generate_pair_no_throw(
        curve: cx_curve_t,
        pubkey: *mut cx_ecfp_public_key_t,
        privkey: *mut cx_ecfp_private_key_t,
        keepprivate: bool,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecfp_generate_pair2_no_throw(
        curve: cx_curve_t,
        pubkey: *mut cx_ecfp_public_key_t,
        privkey: *mut cx_ecfp_private_key_t,
        keepprivate: bool,
        hashID: cx_md_t,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_eddsa_get_public_key_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        hashID: cx_md_t,
        pukey: *mut cx_ecfp_public_key_t,
        a: *mut u8,
        a_len: usize,
        h: *mut u8,
        h_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_edwards_compress_point_no_throw(
        curve: cx_curve_t,
        p: *mut u8,
        p_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_edwards_decompress_point_no_throw(
        curve: cx_curve_t,
        p: *mut u8,
        p_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecdsa_sign_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        mode: u32,
        hashID: cx_md_t,
        hash: *const u8,
        hash_len: usize,
        sig: *mut u8,
        sig_len: *mut usize,
        info: *mut u32,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecdsa_sign_rs_no_throw(
        key: *const cx_ecfp_private_key_t,
        mode: u32,
        hashID: cx_md_t,
        hash: *const u8,
        hash_len: usize,
        rs_len: usize,
        sig_r: *mut u8,
        sig_s: *mut u8,
        info: *mut u32,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecdsa_verify_no_throw(
        pukey: *const cx_ecfp_public_key_t,
        hash: *const u8,
        hash_len: usize,
        sig: *const u8,
        sig_len: usize,
    ) -> bool;
}
extern "C" {
    pub fn cx_eddsa_sign_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        hashID: cx_md_t,
        hash: *const u8,
        hash_len: usize,
        sig: *mut u8,
        sig_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_eddsa_verify_no_throw(
        pukey: *const cx_ecfp_public_key_t,
        hashID: cx_md_t,
        hash: *const u8,
        hash_len: usize,
        sig: *const u8,
        sig_len: usize,
    ) -> bool;
}
extern "C" {
    pub fn cx_encode_coord(coord: *mut u8, len: ::core::ffi::c_int, sign: ::core::ffi::c_int);
}
extern "C" {
    pub fn cx_decode_coord(coord: *mut u8, len: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn cx_ecschnorr_sign_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        mode: u32,
        hashID: cx_md_t,
        msg: *const u8,
        msg_len: usize,
        sig: *mut u8,
        sig_len: *mut usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_ecschnorr_verify(
        pukey: *const cx_ecfp_public_key_t,
        mode: u32,
        hashID: cx_md_t,
        msg: *const u8,
        msg_len: usize,
        sig: *const u8,
        sig_len: usize,
    ) -> bool;
}
extern "C" {
    pub fn cx_ecdh_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        mode: u32,
        P: *const u8,
        P_len: usize,
        secret: *mut u8,
        secret_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_x25519(u: *mut u8, k: *const u8, k_len: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_x448(u: *mut u8, k: *const u8, k_len: usize) -> cx_err_t;
}
extern "C" {
    pub fn cx_crc16(buffer: *const ::core::ffi::c_void, len: usize) -> u16;
}
extern "C" {
    pub fn cx_crc16_update(crc: u16, buffer: *const ::core::ffi::c_void, len: usize) -> u16;
}
extern "C" {
    pub fn os_endorsement_get_code_hash(buffer: *mut ::core::ffi::c_uchar) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_endorsement_get_public_key(
        index: ::core::ffi::c_uchar,
        buffer: *mut ::core::ffi::c_uchar,
        length: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_endorsement_get_public_key_certificate(
        index: ::core::ffi::c_uchar,
        buffer: *mut ::core::ffi::c_uchar,
        length: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_endorsement_key1_get_app_secret(
        buffer: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_endorsement_key1_sign_data(
        src: *mut ::core::ffi::c_uchar,
        srcLength: ::core::ffi::c_uint,
        signature: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_endorsement_key2_derive_sign_data(
        src: *mut ::core::ffi::c_uchar,
        srcLength: ::core::ffi::c_uint,
        signature: *mut ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn halt();
}
pub type bolos_bool_t = u8;
pub type bolos_task_status_t = ::core::ffi::c_uchar;
pub const TASK_BOLOS: task_unsecure_id_e = 0;
pub const TASK_SYSCALL: task_unsecure_id_e = 1;
pub const TASK_USERTASKS_START: task_unsecure_id_e = 2;
pub const TASK_USER: task_unsecure_id_e = 2;
pub const TASK_SUBTASKS_START: task_unsecure_id_e = 3;
pub const TASK_SUBTASK_0: task_unsecure_id_e = 3;
pub const TASK_SUBTASK_1: task_unsecure_id_e = 4;
pub const TASK_SUBTASK_2: task_unsecure_id_e = 5;
pub const TASK_SUBTASK_3: task_unsecure_id_e = 6;
pub const TASK_BOLOS_UX: task_unsecure_id_e = 7;
pub const TASK_MAXCOUNT: task_unsecure_id_e = 8;
pub type task_unsecure_id_e = ::core::ffi::c_uchar;
extern "C" {
    pub fn os_sched_exec(app_idx: ::core::ffi::c_uint);
}
extern "C" {
    pub fn os_sched_exit(exit_code: bolos_task_status_t) -> !;
}
extern "C" {
    pub fn os_sched_is_running(task_idx: ::core::ffi::c_uint) -> bolos_bool_t;
}
extern "C" {
    pub fn os_sched_last_status(task_idx: ::core::ffi::c_uint) -> bolos_task_status_t;
}
extern "C" {
    pub fn os_sched_yield(status: bolos_task_status_t);
}
extern "C" {
    pub fn os_sched_switch(task_idx: ::core::ffi::c_uint, status: bolos_task_status_t);
}
extern "C" {
    pub fn os_sched_current_task() -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_sched_create(
        _start: *mut ::core::ffi::c_void,
        nvram: *mut ::core::ffi::c_void,
        nvram_length: ::core::ffi::c_uint,
        ram0: *mut ::core::ffi::c_void,
        ram0_length: ::core::ffi::c_uint,
        stack: *mut ::core::ffi::c_void,
        stack_length: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_sched_kill(taskidx: ::core::ffi::c_uint);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bolos_ux_asynch_callback_t {
    pub asynchmodal_end_callback:
        ::core::option::Option<unsafe extern "C" fn(ux_status: ::core::ffi::c_uint)>,
}
#[test]
fn bindgen_test_layout_bolos_ux_asynch_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<bolos_ux_asynch_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_asynch_callback_t>(),
        4usize,
        concat!("Size of: ", stringify!(bolos_ux_asynch_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_asynch_callback_t>(),
        4usize,
        concat!("Alignment of ", stringify!(bolos_ux_asynch_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).asynchmodal_end_callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_asynch_callback_t),
            "::",
            stringify!(asynchmodal_end_callback)
        )
    );
}
extern "C" {
    pub static mut G_io_asynch_ux_callback: bolos_ux_asynch_callback_t;
}
extern "C" {
    pub fn os_flags() -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_version(
        version: *mut ::core::ffi::c_uchar,
        maxlength: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_serial(
        serial: *mut ::core::ffi::c_uchar,
        maxlength: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_seph_serial(
        serial: *mut ::core::ffi::c_uchar,
        maxlength: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_seph_features() -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_seph_version(
        version: *mut ::core::ffi::c_uchar,
        maxlength: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_bootloader_version(
        version: *mut ::core::ffi::c_uchar,
        maxlength: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_get_sn(buffer: *mut ::core::ffi::c_uchar) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn get_api_level() -> ::core::ffi::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apdu_buffer_s {
    pub buf: *mut u8,
    pub len: u16,
}
#[test]
fn bindgen_test_layout_apdu_buffer_s() {
    const UNINIT: ::core::mem::MaybeUninit<apdu_buffer_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<apdu_buffer_s>(),
        8usize,
        concat!("Size of: ", stringify!(apdu_buffer_s))
    );
    assert_eq!(
        ::core::mem::align_of::<apdu_buffer_s>(),
        4usize,
        concat!("Alignment of ", stringify!(apdu_buffer_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apdu_buffer_s),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(apdu_buffer_s),
            "::",
            stringify!(len)
        )
    );
}
impl Default for apdu_buffer_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type apdu_buffer_t = apdu_buffer_s;
extern "C" {
    pub static mut G_io_apdu_buffer: [::core::ffi::c_uchar; 260usize];
}
extern "C" {
    pub fn io_exchange(
        channel_and_flags: ::core::ffi::c_uchar,
        tx_len: ::core::ffi::c_ushort,
    ) -> ::core::ffi::c_ushort;
}
pub const IO_APDU_MEDIA_NONE: io_apdu_media_t = 0;
pub const IO_APDU_MEDIA_USB_HID: io_apdu_media_t = 1;
pub const IO_APDU_MEDIA_BLE: io_apdu_media_t = 2;
pub const IO_APDU_MEDIA_NFC: io_apdu_media_t = 3;
pub const IO_APDU_MEDIA_USB_CCID: io_apdu_media_t = 4;
pub const IO_APDU_MEDIA_USB_WEBUSB: io_apdu_media_t = 5;
pub const IO_APDU_MEDIA_RAW: io_apdu_media_t = 6;
pub const IO_APDU_MEDIA_U2F: io_apdu_media_t = 7;
pub type io_apdu_media_t = ::core::ffi::c_uchar;
extern "C" {
    pub static mut G_io_usb_ep_buffer: [::core::ffi::c_uchar; 64usize];
}
extern "C" {
    pub fn io_event(channel: ::core::ffi::c_uchar) -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn os_lib_call(call_parameters: *mut ::core::ffi::c_uint);
}
extern "C" {
    pub fn os_lib_end() -> !;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct meminfo_s {
    pub free_nvram_size: ::core::ffi::c_uint,
    pub appMemory: ::core::ffi::c_uint,
    pub systemSize: ::core::ffi::c_uint,
    pub slots: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_meminfo_s() {
    const UNINIT: ::core::mem::MaybeUninit<meminfo_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<meminfo_s>(),
        16usize,
        concat!("Size of: ", stringify!(meminfo_s))
    );
    assert_eq!(
        ::core::mem::align_of::<meminfo_s>(),
        4usize,
        concat!("Alignment of ", stringify!(meminfo_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_nvram_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(free_nvram_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).appMemory) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(appMemory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).systemSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(systemSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slots) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(slots)
        )
    );
}
pub type meminfo_t = meminfo_s;
extern "C" {
    pub fn os_get_memory_info(meminfo: *mut meminfo_t);
}
extern "C" {
    pub fn nvm_write(
        dst_adr: *mut ::core::ffi::c_void,
        src_adr: *mut ::core::ffi::c_void,
        src_len: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn nvm_erase(dst_adr: *mut ::core::ffi::c_void, len: ::core::ffi::c_uint);
}
extern "C" {
    pub fn nvm_write_page(page_adr: ::core::ffi::c_uint, force: bool);
}
extern "C" {
    pub fn nvm_erase_page(page_adr: ::core::ffi::c_uint);
}
extern "C" {
    pub fn os_perso_erase_all();
}
extern "C" {
    pub fn erase_all_except_user_config_apps();
}
extern "C" {
    pub fn pic(linked_address: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn pic_internal(link_address: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn os_perso_set_pin(
        identity: ::core::ffi::c_uint,
        pin: *const ::core::ffi::c_uchar,
        length: ::core::ffi::c_uint,
        update_crc: bool,
    );
}
extern "C" {
    pub fn os_perso_set_current_identity_pin(
        pin: *mut ::core::ffi::c_uchar,
        length: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_global_pin_is_validated() -> bolos_bool_t;
}
extern "C" {
    pub fn os_global_pin_check(
        pin_buffer: *mut ::core::ffi::c_uchar,
        pin_length: ::core::ffi::c_uchar,
    ) -> bolos_bool_t;
}
extern "C" {
    pub fn os_global_pin_invalidate();
}
extern "C" {
    pub fn os_global_pin_retries() -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_perso_is_pin_set() -> bolos_bool_t;
}
extern "C" {
    pub fn cx_get_random_bytes(buffer: *mut ::core::ffi::c_void, len: usize) -> cx_err_t;
}
pub type appmain_t = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct application_s {
    pub nvram_begin: *mut ::core::ffi::c_uchar,
    pub nvram_end: *mut ::core::ffi::c_uchar,
    pub _start: appmain_t,
    pub flags: u32,
    pub code_length: ::core::ffi::c_uint,
    pub data_length: ::core::ffi::c_uint,
    pub params_length: ::core::ffi::c_uint,
    pub sha256_code_data: [::core::ffi::c_uchar; 32usize],
    pub sha256_full: [::core::ffi::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_application_s() {
    const UNINIT: ::core::mem::MaybeUninit<application_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<application_s>(),
        92usize,
        concat!("Size of: ", stringify!(application_s))
    );
    assert_eq!(
        ::core::mem::align_of::<application_s>(),
        4usize,
        concat!("Alignment of ", stringify!(application_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvram_begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(nvram_begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvram_end) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(nvram_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).code_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(code_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(params_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sha256_code_data) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(sha256_code_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sha256_full) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(sha256_full)
        )
    );
}
impl Default for application_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type application_t = application_s;
extern "C" {
    pub fn os_registry_get_tag(
        app_idx: ::core::ffi::c_uint,
        tlvoffset: *mut ::core::ffi::c_uint,
        tag: ::core::ffi::c_uint,
        value_offset: ::core::ffi::c_uint,
        buffer: *mut ::core::ffi::c_void,
        maxlength: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_registry_get_current_app_tag(
        tag: ::core::ffi::c_uint,
        buffer: *mut ::core::ffi::c_uchar,
        maxlen: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_registry_delete_app_and_dependees(app_idx: ::core::ffi::c_uint);
}
extern "C" {
    pub fn os_registry_delete_all_apps();
}
extern "C" {
    pub fn os_registry_count() -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_registry_get(app_idx: ::core::ffi::c_uint, out_application_entry: *mut application_t);
}
extern "C" {
    pub fn screen_init();
}
extern "C" {
    pub fn screen_clear();
}
extern "C" {
    pub fn screen_update();
}
extern "C" {
    pub fn screen_set_brightness(percent: ::core::ffi::c_uint);
}
extern "C" {
    pub fn screen_set_keepout(
        x: ::core::ffi::c_uint,
        y: ::core::ffi::c_uint,
        width: ::core::ffi::c_uint,
        height: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bagl_hal_draw_bitmap_within_rect(
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        width: ::core::ffi::c_uint,
        height: ::core::ffi::c_uint,
        color_count: ::core::ffi::c_uint,
        colors: *const ::core::ffi::c_uint,
        bit_per_pixel: ::core::ffi::c_uint,
        bitmap: *const ::core::ffi::c_uchar,
        bitmap_length_bits: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bagl_hal_draw_rect(
        color: ::core::ffi::c_uint,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        width: ::core::ffi::c_uint,
        height: ::core::ffi::c_uint,
    );
}
pub const SET_SEED: os_action_t = 0;
pub const SET_STATE: os_action_t = 1;
pub const GET_STATE: os_action_t = 2;
pub type os_action_t = ::core::ffi::c_uchar;
extern "C" {
    pub fn os_perso_set_seed(
        identity: ::core::ffi::c_uint,
        algorithm: ::core::ffi::c_uint,
        seed: *mut ::core::ffi::c_uchar,
        length: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_perso_derive_and_set_seed(
        identity: ::core::ffi::c_uchar,
        prefix: *const ::core::ffi::c_char,
        prefix_length: ::core::ffi::c_uint,
        passphrase: *const ::core::ffi::c_char,
        passphrase_length: ::core::ffi::c_uint,
        words: *const ::core::ffi::c_char,
        words_length: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_perso_set_words(words: *const ::core::ffi::c_uchar, length: ::core::ffi::c_uint);
}
extern "C" {
    pub fn os_perso_finalize();
}
extern "C" {
    pub fn os_perso_isonboarded() -> bolos_bool_t;
}
pub const ONBOARDING_STATUS_WELCOME: _bindgen_ty_1 = 0;
pub const ONBOARDING_STATUS_WELCOME_STEP2: _bindgen_ty_1 = 1;
pub const ONBOARDING_STATUS_WELCOME_STEP5: _bindgen_ty_1 = 2;
pub const ONBOARDING_STATUS_WELCOME_STEP6: _bindgen_ty_1 = 3;
pub const ONBOARDING_STATUS_WELCOME_REMEMBER: _bindgen_ty_1 = 4;
pub const ONBOARDING_STATUS_SETUP_CHOICE: _bindgen_ty_1 = 5;
pub const ONBOARDING_STATUS_PIN: _bindgen_ty_1 = 6;
pub const ONBOARDING_STATUS_NEW_DEVICE: _bindgen_ty_1 = 7;
pub const ONBOARDING_STATUS_NEW_DEVICE_CONFIRMING: _bindgen_ty_1 = 8;
pub const ONBOARDING_STATUS_RESTORE_SEED: _bindgen_ty_1 = 9;
pub const ONBOARDING_STATUS_SAFETY_WARNINGS: _bindgen_ty_1 = 10;
pub const ONBOARDING_STATUS_READY: _bindgen_ty_1 = 11;
pub const ONBOARDING_STATUS_CHOOSE_NAME: _bindgen_ty_1 = 12;
pub const ONBOARDING_STATUS_RECOVER_RESTORE_SEED: _bindgen_ty_1 = 13;
pub const ONBOARDING_STATUS_SETUP_CHOICE_RESTORE_SEED: _bindgen_ty_1 = 14;
pub type _bindgen_ty_1 = ::core::ffi::c_uchar;
extern "C" {
    pub fn os_perso_set_onboarding_status(
        state: ::core::ffi::c_uint,
        count: ::core::ffi::c_uint,
        total: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_perso_derive_node_bip32(
        curve: cx_curve_t,
        path: *const ::core::ffi::c_uint,
        pathLength: ::core::ffi::c_uint,
        privateKey: *mut ::core::ffi::c_uchar,
        chain: *mut ::core::ffi::c_uchar,
    );
}
extern "C" {
    pub fn os_perso_derive_node_with_seed_key(
        mode: ::core::ffi::c_uint,
        curve: cx_curve_t,
        path: *const ::core::ffi::c_uint,
        pathLength: ::core::ffi::c_uint,
        privateKey: *mut ::core::ffi::c_uchar,
        chain: *mut ::core::ffi::c_uchar,
        seed_key: *mut ::core::ffi::c_uchar,
        seed_key_length: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_perso_derive_eip2333(
        curve: cx_curve_t,
        path: *const ::core::ffi::c_uint,
        pathLength: ::core::ffi::c_uint,
        privateKey: *mut ::core::ffi::c_uchar,
    );
}
pub const OS_SETTING_BRIGHTNESS_V0: os_setting_v0_e = 0;
pub const OS_SETTING_INVERT_V0: os_setting_v0_e = 1;
pub const OS_SETTING_ROTATION_V0: os_setting_v0_e = 2;
pub const OS_SETTING_MCU_UPGRADE_V0: os_setting_v0_e = 2;
pub const OS_SETTING_AUTO_LOCK_DELAY_V0: os_setting_v0_e = 3;
pub const OS_SETTING_SCREEN_LOCK_DELAY_V0: os_setting_v0_e = 4;
pub const OS_SETTING_POWER_OFF_DELAY_V0: os_setting_v0_e = 5;
pub const OS_SETTING_PLANEMODE_V0: os_setting_v0_e = 6;
pub const OS_SETTING_PRIVACY_MODE_V0: os_setting_v0_e = 7;
pub const OS_SETTING_LAST_INT_V0: os_setting_v0_e = 8;
pub const OS_SETTING_SAVER_STRING_V0: os_setting_v0_e = 8;
pub const OS_SETTING_DEVICENAME_V0: os_setting_v0_e = 9;
pub const OS_SETTING_BLEMACADR_V0: os_setting_v0_e = 10;
pub const OS_SETTING_LAST_V0: os_setting_v0_e = 11;
pub type os_setting_v0_e = ::core::ffi::c_uchar;
pub use self::os_setting_v0_e as os_setting_v0_t;
pub const OS_SETTING_BRIGHTNESS_V1: os_setting_v1_e = 0;
pub const OS_SETTING_INVERT_V1: os_setting_v1_e = 1;
pub const OS_SETTING_ROTATION_V1: os_setting_v1_e = 2;
pub const OS_SETTING_MCU_UPGRADE_V1: os_setting_v1_e = 2;
pub const OS_SETTING_AUTO_LOCK_DELAY_V1: os_setting_v1_e = 3;
pub const OS_SETTING_SCREEN_LOCK_DELAY_V1: os_setting_v1_e = 4;
pub const OS_SETTING_POWER_OFF_DELAY_V1: os_setting_v1_e = 5;
pub const OS_SETTING_PLANEMODE_V1: os_setting_v1_e = 6;
pub const OS_SETTING_PRIVACY_MODE_V1: os_setting_v1_e = 7;
pub const OS_SETTING_LANGUAGE_V1: os_setting_v1_e = 8;
pub const OS_SETTING_LAST_INT_V1: os_setting_v1_e = 9;
pub const OS_SETTING_SAVER_STRING_V1: os_setting_v1_e = 9;
pub const OS_SETTING_DEVICENAME_V1: os_setting_v1_e = 10;
pub const OS_SETTING_BLEMACADR_V1: os_setting_v1_e = 11;
pub const OS_SETTING_LAST_V1: os_setting_v1_e = 12;
pub type os_setting_v1_e = ::core::ffi::c_uchar;
pub use self::os_setting_v1_e as os_setting_v1_t;
pub const OS_SETTING_BRIGHTNESS: os_setting_e = 0;
pub const OS_SETTING_INVERT: os_setting_e = 1;
pub const OS_SETTING_ROTATION: os_setting_e = 2;
pub const OS_SETTING_MCU_UPGRADE: os_setting_e = 2;
pub const OS_SETTING_AUTO_LOCK_DELAY: os_setting_e = 3;
pub const OS_SETTING_SCREEN_LOCK_DELAY: os_setting_e = 4;
pub const OS_SETTING_POWER_OFF_DELAY: os_setting_e = 5;
pub const OS_SETTING_PLANEMODE: os_setting_e = 6;
pub const OS_SETTING_PRIVACY_MODE: os_setting_e = 7;
pub const OS_SETTING_LANGUAGE: os_setting_e = 8;
pub const OS_SETTING_PIEZO_SOUND: os_setting_e = 9;
pub const OS_SETTING_LAST_INT: os_setting_e = 10;
pub const OS_SETTING_SAVER_STRING: os_setting_e = 10;
pub const OS_SETTING_DEVICENAME: os_setting_e = 11;
pub const OS_SETTING_BLEMACADR: os_setting_e = 12;
pub const OS_SETTING_NFC_TAG_CONTENT: os_setting_e = 13;
pub const OS_SETTING_FEATURES: os_setting_e = 14;
pub const OS_SETTING_LAST: os_setting_e = 15;
pub type os_setting_e = ::core::ffi::c_uchar;
pub use self::os_setting_e as os_setting_t;
extern "C" {
    pub fn os_setting_get(
        setting_id: ::core::ffi::c_uint,
        value: *mut ::core::ffi::c_uchar,
        maxlen: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_setting_set(
        setting_id: ::core::ffi::c_uint,
        value: *mut ::core::ffi::c_uchar,
        length: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_setting_get_default_device_name(
        buffer: *mut ::core::ffi::c_uchar,
        maxlength: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn u4be_encode(
        buffer: *mut ::core::ffi::c_uchar,
        offset: ::core::ffi::c_uint,
        value: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn u4le_encode(
        buffer: *mut ::core::ffi::c_uchar,
        offset: ::core::ffi::c_uint,
        value: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bytes_to_hex(
        out: *mut ::core::ffi::c_char,
        outl: usize,
        value: *const ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn bytes_to_lowercase_hex(
        out: *mut ::core::ffi::c_char,
        outl: usize,
        value: *const ::core::ffi::c_void,
        len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn os_memset4(
        dst: *mut ::core::ffi::c_void,
        initval: ::core::ffi::c_uint,
        nbintval: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_xor(
        dst: *mut ::core::ffi::c_void,
        src1: *mut ::core::ffi::c_void,
        src2: *mut ::core::ffi::c_void,
        length: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn os_secure_memcmp(
        src1: *const ::core::ffi::c_void,
        src2: *const ::core::ffi::c_void,
        length: usize,
    ) -> ::core::ffi::c_char;
}
extern "C" {
    pub fn os_memmove(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        n: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn os_memcpy(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        n: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn os_memcmp(
        s1: *const ::core::ffi::c_void,
        s2: *const ::core::ffi::c_void,
        n: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn os_memset(
        s: *mut ::core::ffi::c_void,
        c: ::core::ffi::c_int,
        n: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn os_explicit_zero_BSS_segment();
}
extern "C" {
    pub fn app_main();
}
extern "C" {
    pub fn os_boot();
}
extern "C" {
    pub fn io_timeout(last_timeout: ::core::ffi::c_ushort) -> ::core::ffi::c_ushort;
}
extern "C" {
    pub fn compute_address_location(address: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
pub const BOLOS_UX_INITIALIZE: bolos_ux_e = 0;
pub const BOLOS_UX_EVENT: bolos_ux_e = 1;
pub const BOLOS_UX_KEYBOARD: bolos_ux_e = 2;
pub const BOLOS_UX_WAKE_UP: bolos_ux_e = 3;
pub const BOLOS_UX_STATUS_BAR: bolos_ux_e = 4;
pub const BOLOS_UX_VALIDATE_PIN: bolos_ux_e = 5;
pub const BOLOS_UX_ASYNCHMODAL_PAIRING_REQUEST: bolos_ux_e = 6;
pub const BOLOS_UX_ASYNCHMODAL_PAIRING_CANCEL: bolos_ux_e = 7;
pub const BOLOS_UX_LAST_ID: bolos_ux_e = 8;
pub type bolos_ux_e = ::core::ffi::c_uchar;
pub use self::bolos_ux_e as bolos_ux_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s {
    pub ux_id: bolos_ux_t,
    pub len: ::core::ffi::c_uint,
    pub u: bolos_ux_params_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bolos_ux_params_s__bindgen_ty_1 {
    pub pairing_request: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1,
    pub pairing_status: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1 {
    pub type_: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub pairing_info_len: ::core::ffi::c_uint,
    pub pairing_info: [::core::ffi::c_char; 16usize],
}
pub const BOLOS_UX_ASYNCHMODAL_PAIRING_REQUEST_PASSKEY:
    bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 = 0;
pub const BOLOS_UX_ASYNCHMODAL_PAIRING_REQUEST_NUMCOMP:
    bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 = 1;
pub type bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 = ::core::ffi::c_uchar;
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pairing_info_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pairing_info_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pairing_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pairing_info)
        )
    );
}
impl Default for bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2 {
    pub pairing_ok: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
pub const BOLOS_UX_ASYNCHMODAL_PAIRING_STATUS_CONFIRM_CODE_YES:
    bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 = 0;
pub const BOLOS_UX_ASYNCHMODAL_PAIRING_STATUS_CONFIRM_CODE_NO:
    bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 = 1;
pub const BOLOS_UX_ASYNCHMODAL_PAIRING_STATUS_ACCEPT_PASSKEY:
    bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 = 2;
pub const BOLOS_UX_ASYNCHMODAL_PAIRING_STATUS_CANCEL_PASSKEY:
    bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 = 3;
pub const BOLOS_UX_ASYNCHMODAL_PAIRING_STATUS_SUCCESS:
    bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 = 4;
pub const BOLOS_UX_ASYNCHMODAL_PAIRING_STATUS_TIMEOUT:
    bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 = 5;
pub const BOLOS_UX_ASYNCHMODAL_PAIRING_STATUS_FAILED:
    bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 = 6;
pub const BOLOS_UX_ASYNCHMODAL_PAIRING_STATUS_CANCELLED_FROM_REMOTE:
    bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 = 7;
pub type bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 = ::core::ffi::c_uchar;
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pairing_ok) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(pairing_ok)
        )
    );
}
impl Default for bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<bolos_ux_params_s__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(bolos_ux_params_s__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(bolos_ux_params_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pairing_request) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(pairing_request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pairing_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(pairing_status)
        )
    );
}
impl Default for bolos_ux_params_s__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s() {
    const UNINIT: ::core::mem::MaybeUninit<bolos_ux_params_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s>(),
        32usize,
        concat!("Size of: ", stringify!(bolos_ux_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(bolos_ux_params_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ux_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s),
            "::",
            stringify!(ux_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s),
            "::",
            stringify!(u)
        )
    );
}
impl Default for bolos_ux_params_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type bolos_ux_params_t = bolos_ux_params_s;
extern "C" {
    pub fn os_ux(params: *mut bolos_ux_params_t) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_ux_result(params: *mut bolos_ux_params_t);
}
extern "C" {
    pub fn os_ux_blocking(params: *mut bolos_ux_params_t) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn os_ux_set_status(ux_id: ::core::ffi::c_uint, status: ::core::ffi::c_uint);
}
extern "C" {
    pub fn os_ux_get_status(ux_id: ::core::ffi::c_uint) -> ::core::ffi::c_uint;
}
extern "C" {
    pub static mut G_io_seproxyhal_spi_buffer: [::core::ffi::c_uchar; 128usize];
}
extern "C" {
    pub fn io_seph_send(buffer: *const ::core::ffi::c_uchar, length: ::core::ffi::c_ushort);
}
extern "C" {
    pub fn io_seph_is_status_sent() -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn io_seph_recv(
        buffer: *mut ::core::ffi::c_uchar,
        maxlength: ::core::ffi::c_ushort,
        flags: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_ushort;
}
extern "C" {
    pub fn io_seph_init();
}
extern "C" {
    pub fn io_seproxyhal_init();
}
extern "C" {
    pub fn io_seproxyhal_init_ux();
}
extern "C" {
    pub fn io_seproxyhal_init_button();
}
extern "C" {
    pub fn io_exchange_al(
        channel_and_flags: ::core::ffi::c_uchar,
        tx_len: ::core::ffi::c_ushort,
    ) -> ::core::ffi::c_ushort;
}
extern "C" {
    pub fn os_io_seproxyhal_get_app_name_and_version() -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn BLE_power(powered: ::core::ffi::c_uchar, discovered_name: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn USB_power(enabled: ::core::ffi::c_uchar);
}
extern "C" {
    pub fn io_seproxyhal_handle_usb_event();
}
extern "C" {
    pub fn io_seproxyhal_handle_usb_ep_xfer_event();
}
extern "C" {
    pub fn io_seproxyhal_get_ep_rx_size(epnum: u8) -> u16;
}
extern "C" {
    pub fn io_seproxyhal_handle_event() -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn io_seproxyhal_general_status();
}
extern "C" {
    pub fn os_io_seproxyhal_general_status_processing();
}
extern "C" {
    pub fn io_usb_send_apdu_data(buffer: *mut ::core::ffi::c_uchar, length: ::core::ffi::c_ushort);
}
extern "C" {
    pub fn io_usb_send_apdu_data_ep0x83(
        buffer: *mut ::core::ffi::c_uchar,
        length: ::core::ffi::c_ushort,
    );
}
extern "C" {
    pub fn io_usb_send_ep(
        ep: ::core::ffi::c_uint,
        buffer: *mut ::core::ffi::c_uchar,
        length: ::core::ffi::c_ushort,
        timeout: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn io_usb_ccid_reply(buffer: *mut ::core::ffi::c_uchar, length: ::core::ffi::c_ushort);
}
extern "C" {
    pub fn io_set_timeout(timeout: ::core::ffi::c_uint);
}
pub const APDU_IDLE: io_apdu_state_e = 0;
pub const APDU_BLE: io_apdu_state_e = 1;
pub const APDU_BLE_WAIT_NOTIFY: io_apdu_state_e = 2;
pub const APDU_NFC_M24SR: io_apdu_state_e = 3;
pub const APDU_NFC_M24SR_SELECT: io_apdu_state_e = 4;
pub const APDU_NFC_M24SR_FIRST: io_apdu_state_e = 5;
pub const APDU_NFC_M24SR_RAPDU: io_apdu_state_e = 6;
pub const APDU_USB_HID: io_apdu_state_e = 7;
pub const APDU_USB_CCID: io_apdu_state_e = 8;
pub const APDU_U2F: io_apdu_state_e = 9;
pub const APDU_RAW: io_apdu_state_e = 10;
pub const APDU_USB_WEBUSB: io_apdu_state_e = 11;
pub type io_apdu_state_e = ::core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_seph_s {
    pub apdu_state: io_apdu_state_e,
    pub apdu_length: ::core::ffi::c_ushort,
    pub io_flags: ::core::ffi::c_ushort,
    pub apdu_media: io_apdu_media_t,
    pub ms: ::core::ffi::c_uint,
    pub usb_ep_xfer_len: [::core::ffi::c_uchar; 6usize],
    pub usb_ep_timeouts: [io_seph_s__bindgen_ty_1; 6usize],
    pub ble_xfer_timeout: ::core::ffi::c_ushort,
    pub plane_mode: ::core::ffi::c_uint,
    pub ble_ready: ::core::ffi::c_uchar,
    pub name_changed: ::core::ffi::c_uchar,
    pub enabling_advertising: ::core::ffi::c_uchar,
    pub disabling_advertising: ::core::ffi::c_uchar,
    pub transfer_mode: ::core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_seph_s__bindgen_ty_1 {
    pub timeout: ::core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout_io_seph_s__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<io_seph_s__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<io_seph_s__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(io_seph_s__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<io_seph_s__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(io_seph_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s__bindgen_ty_1),
            "::",
            stringify!(timeout)
        )
    );
}
#[test]
fn bindgen_test_layout_io_seph_s() {
    const UNINIT: ::core::mem::MaybeUninit<io_seph_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<io_seph_s>(),
        44usize,
        concat!("Size of: ", stringify!(io_seph_s))
    );
    assert_eq!(
        ::core::mem::align_of::<io_seph_s>(),
        4usize,
        concat!("Alignment of ", stringify!(io_seph_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).apdu_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(apdu_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).apdu_length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(apdu_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).io_flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(io_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).apdu_media) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(apdu_media)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(ms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).usb_ep_xfer_len) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(usb_ep_xfer_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).usb_ep_timeouts) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(usb_ep_timeouts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ble_xfer_timeout) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(ble_xfer_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plane_mode) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(plane_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ble_ready) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(ble_ready)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name_changed) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(name_changed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enabling_advertising) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(enabling_advertising)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disabling_advertising) as usize - ptr as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(disabling_advertising)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transfer_mode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(transfer_mode)
        )
    );
}
impl Default for io_seph_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type io_seph_app_t = io_seph_s;
extern "C" {
    pub static mut G_io_app: io_seph_app_t;
}
extern "C" {
    pub fn io_seproxyhal_setup_ticker(interval_ms: ::core::ffi::c_uint);
}
extern "C" {
    pub fn io_seproxyhal_power_off();
}
extern "C" {
    pub fn io_seproxyhal_se_reset();
}
extern "C" {
    pub fn io_seproxyhal_disable_io();
}
extern "C" {
    pub fn io_seph_ble_enable(enable: ::core::ffi::c_uchar);
}
extern "C" {
    pub fn io_seph_ble_clear_bond_db();
}
extern "C" {
    pub fn io_seph_ble_name_changed();
}
extern "C" {
    pub fn io_seph_ux_redisplay();
}
extern "C" {
    pub fn io_seproxyhal_io_heartbeat();
}
extern "C" {
    pub fn os_io_seph_recv_and_process(
        dont_process_ux_events: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: ::core::ffi::c_int,
    pub rem: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::core::mem::MaybeUninit<div_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<ldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::core::ffi::c_longlong,
    pub rem: ::core::ffi::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<lldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::core::ffi::c_void, arg2: usize);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const ::core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const ::core::ffi::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _atoi_r(arg1: *mut _reent, __nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _atol_r(arg1: *mut _reent, __nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::core::ffi::c_void,
        __base: *const ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn calloc(arg1: ::core::ffi::c_uint, arg2: ::core::ffi::c_uint)
        -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn div(__numer: ::core::ffi::c_int, __denom: ::core::ffi::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn free(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn getenv(__string: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const *mut ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn labs(arg1: ::core::ffi::c_long) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn ldiv(__numer: ::core::ffi::c_long, __denom: ::core::ffi::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(arg1: ::core::ffi::c_uint) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const ::core::ffi::c_char, arg2: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::core::ffi::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::core::ffi::c_char, arg2: wchar_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::core::ffi::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::core::ffi::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::core::ffi::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mkstemps(arg1: *mut ::core::ffi::c_char, arg2: ::core::ffi::c_int)
        -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mktemp_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char)
        -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn realloc(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn reallocf(arg1: *mut ::core::ffi::c_void, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const ::core::ffi::c_char,
        resolved_path: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn srand(__seed: ::core::ffi::c_uint);
}
extern "C" {
    pub fn strtod(__n: *const ::core::ffi::c_char, __end_PTR: *mut *mut ::core::ffi::c_char)
        -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(__n: *const ::core::ffi::c_char, __end_PTR: *mut *mut ::core::ffi::c_char)
        -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn system(__string: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn a64l(__input: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn l64a(__input: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _l64a_r(arg1: *mut _reent, __input: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: ::core::ffi::c_int, arg2: *mut ::core::ffi::c_void),
        >,
        __arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _Exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn putenv(__string: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putenv_r(arg1: *mut _reent, __string: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const ::core::ffi::c_char,
        __value: *const ::core::ffi::c_char,
        __overwrite: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const ::core::ffi::c_char,
        __value: *const ::core::ffi::c_char,
        __overwrite: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut ::core::ffi::c_uint) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut ::core::ffi::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _jrand48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::core::ffi::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn mrand48() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _nrand48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut ::core::ffi::c_ushort) -> *mut ::core::ffi::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_ushort,
    ) -> *mut ::core::ffi::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: ::core::ffi::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: ::core::ffi::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn random() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn srandom(arg1: ::core::ffi::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn lldiv(__numer: ::core::ffi::c_longlong, __denom: ::core::ffi::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
        arg5: *mut ::core::ffi::c_int,
        arg6: *mut ::core::ffi::c_int,
        arg7: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn _system_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
        arg4: *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __thunk: *mut ::core::ffi::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
                arg3: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtold(arg1: *const ::core::ffi::c_char, arg2: *mut *mut ::core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn aligned_alloc(
        arg1: ::core::ffi::c_uint,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: ::core::ffi::c_int);
}
extern "C" {
    pub fn USBD_static_malloc(size: u32) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn USBD_static_free(p: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn USBD_GetPinPadOffset() -> *const u8;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_setup_req {
    pub bmRequest: u8,
    pub bRequest: u8,
    pub wValue: u16,
    pub wIndex: u16,
    pub wLength: u16,
}
#[test]
fn bindgen_test_layout_usb_setup_req() {
    const UNINIT: ::core::mem::MaybeUninit<usb_setup_req> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usb_setup_req>(),
        8usize,
        concat!("Size of: ", stringify!(usb_setup_req))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_setup_req>(),
        2usize,
        concat!("Alignment of ", stringify!(usb_setup_req))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bmRequest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_setup_req),
            "::",
            stringify!(bmRequest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bRequest) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_setup_req),
            "::",
            stringify!(bRequest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wValue) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_setup_req),
            "::",
            stringify!(wValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_setup_req),
            "::",
            stringify!(wIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wLength) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_setup_req),
            "::",
            stringify!(wLength)
        )
    );
}
pub type USBD_SetupReqTypedef = usb_setup_req;
pub type Init_t =
    ::core::option::Option<unsafe extern "C" fn(pdev: *mut _USBD_HandleTypeDef, cfgidx: u8) -> u8>;
pub type DeInit_t =
    ::core::option::Option<unsafe extern "C" fn(pdev: *mut _USBD_HandleTypeDef, cfgidx: u8) -> u8>;
pub type Setup_t = ::core::option::Option<
    unsafe extern "C" fn(pdev: *mut _USBD_HandleTypeDef, req: *mut USBD_SetupReqTypedef) -> u8,
>;
pub type EP0_TxSent_t =
    ::core::option::Option<unsafe extern "C" fn(pdev: *mut _USBD_HandleTypeDef) -> u8>;
pub type EP0_RxReady_t =
    ::core::option::Option<unsafe extern "C" fn(pdev: *mut _USBD_HandleTypeDef) -> u8>;
pub type DataIn_t =
    ::core::option::Option<unsafe extern "C" fn(pdev: *mut _USBD_HandleTypeDef, epnum: u8) -> u8>;
pub type DataOut_t = ::core::option::Option<
    unsafe extern "C" fn(
        pdev: *mut _USBD_HandleTypeDef,
        epnum: u8,
        pData: *mut u8,
        arg1: *mut apdu_buffer_t,
    ) -> u8,
>;
pub type SOF_t = ::core::option::Option<unsafe extern "C" fn(pdev: *mut _USBD_HandleTypeDef) -> u8>;
pub type IsoINIncomplete_t =
    ::core::option::Option<unsafe extern "C" fn(pdev: *mut _USBD_HandleTypeDef, epnum: u8) -> u8>;
pub type IsoOUTIncomplete_t =
    ::core::option::Option<unsafe extern "C" fn(pdev: *mut _USBD_HandleTypeDef, epnum: u8) -> u8>;
pub type GetHSConfigDescriptor_t =
    ::core::option::Option<unsafe extern "C" fn(length: *mut u16) -> *mut u8>;
pub type GetFSConfigDescriptor_t =
    ::core::option::Option<unsafe extern "C" fn(length: *mut u16) -> *mut u8>;
pub type GetOtherSpeedConfigDescriptor_t =
    ::core::option::Option<unsafe extern "C" fn(length: *mut u16) -> *mut u8>;
pub type GetDeviceQualifierDescriptor_t =
    ::core::option::Option<unsafe extern "C" fn(length: *mut u16) -> *mut u8>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _Device_cb {
    pub Init: Init_t,
    pub DeInit: DeInit_t,
    pub Setup: Setup_t,
    pub EP0_TxSent: EP0_TxSent_t,
    pub EP0_RxReady: EP0_RxReady_t,
    pub DataIn: DataIn_t,
    pub DataOut: DataOut_t,
    pub SOF: SOF_t,
    pub IsoINIncomplete: IsoINIncomplete_t,
    pub IsoOUTIncomplete: IsoOUTIncomplete_t,
    pub GetHSConfigDescriptor: GetHSConfigDescriptor_t,
    pub GetFSConfigDescriptor: GetFSConfigDescriptor_t,
    pub GetOtherSpeedConfigDescriptor: GetOtherSpeedConfigDescriptor_t,
    pub GetDeviceQualifierDescriptor: GetDeviceQualifierDescriptor_t,
}
#[test]
fn bindgen_test_layout__Device_cb() {
    const UNINIT: ::core::mem::MaybeUninit<_Device_cb> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Device_cb>(),
        56usize,
        concat!("Size of: ", stringify!(_Device_cb))
    );
    assert_eq!(
        ::core::mem::align_of::<_Device_cb>(),
        4usize,
        concat!("Alignment of ", stringify!(_Device_cb))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Device_cb),
            "::",
            stringify!(Init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeInit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Device_cb),
            "::",
            stringify!(DeInit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Setup) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Device_cb),
            "::",
            stringify!(Setup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EP0_TxSent) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Device_cb),
            "::",
            stringify!(EP0_TxSent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EP0_RxReady) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Device_cb),
            "::",
            stringify!(EP0_RxReady)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataIn) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Device_cb),
            "::",
            stringify!(DataIn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataOut) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_Device_cb),
            "::",
            stringify!(DataOut)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SOF) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_Device_cb),
            "::",
            stringify!(SOF)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IsoINIncomplete) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_Device_cb),
            "::",
            stringify!(IsoINIncomplete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IsoOUTIncomplete) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_Device_cb),
            "::",
            stringify!(IsoOUTIncomplete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GetHSConfigDescriptor) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_Device_cb),
            "::",
            stringify!(GetHSConfigDescriptor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GetFSConfigDescriptor) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_Device_cb),
            "::",
            stringify!(GetFSConfigDescriptor)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).GetOtherSpeedConfigDescriptor) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_Device_cb),
            "::",
            stringify!(GetOtherSpeedConfigDescriptor)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).GetDeviceQualifierDescriptor) as usize - ptr as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_Device_cb),
            "::",
            stringify!(GetDeviceQualifierDescriptor)
        )
    );
}
pub type USBD_ClassTypeDef = _Device_cb;
pub const USBD_SPEED_HIGH: USBD_SpeedTypeDef = 0;
pub const USBD_SPEED_FULL: USBD_SpeedTypeDef = 1;
pub const USBD_SPEED_LOW: USBD_SpeedTypeDef = 2;
pub type USBD_SpeedTypeDef = ::core::ffi::c_uchar;
pub const USBD_OK: USBD_StatusTypeDef = 0;
pub const USBD_BUSY: USBD_StatusTypeDef = 1;
pub const USBD_FAIL: USBD_StatusTypeDef = 2;
pub type USBD_StatusTypeDef = ::core::ffi::c_uchar;
pub type GetDeviceDescriptor_t = ::core::option::Option<
    unsafe extern "C" fn(speed: USBD_SpeedTypeDef, length: *mut u16) -> *mut u8,
>;
pub type GetLangIDStrDescriptor_t = ::core::option::Option<
    unsafe extern "C" fn(speed: USBD_SpeedTypeDef, length: *mut u16) -> *mut u8,
>;
pub type GetManufacturerStrDescriptor_t = ::core::option::Option<
    unsafe extern "C" fn(speed: USBD_SpeedTypeDef, length: *mut u16) -> *mut u8,
>;
pub type GetProductStrDescriptor_t = ::core::option::Option<
    unsafe extern "C" fn(speed: USBD_SpeedTypeDef, length: *mut u16) -> *mut u8,
>;
pub type GetSerialStrDescriptor_t = ::core::option::Option<
    unsafe extern "C" fn(speed: USBD_SpeedTypeDef, length: *mut u16) -> *mut u8,
>;
pub type GetConfigurationStrDescriptor_t = ::core::option::Option<
    unsafe extern "C" fn(speed: USBD_SpeedTypeDef, length: *mut u16) -> *mut u8,
>;
pub type GetInterfaceStrDescriptor_t = ::core::option::Option<
    unsafe extern "C" fn(speed: USBD_SpeedTypeDef, length: *mut u16) -> *mut u8,
>;
pub type GetBOSDescriptor_t = ::core::option::Option<
    unsafe extern "C" fn(speed: USBD_SpeedTypeDef, length: *mut u16) -> *mut u8,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USBD_DescriptorsTypeDef {
    pub GetDeviceDescriptor: GetDeviceDescriptor_t,
    pub GetLangIDStrDescriptor: GetLangIDStrDescriptor_t,
    pub GetManufacturerStrDescriptor: GetManufacturerStrDescriptor_t,
    pub GetProductStrDescriptor: GetProductStrDescriptor_t,
    pub GetSerialStrDescriptor: GetSerialStrDescriptor_t,
    pub GetConfigurationStrDescriptor: GetConfigurationStrDescriptor_t,
    pub GetInterfaceStrDescriptor: GetInterfaceStrDescriptor_t,
    pub GetBOSDescriptor: GetBOSDescriptor_t,
}
#[test]
fn bindgen_test_layout_USBD_DescriptorsTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<USBD_DescriptorsTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USBD_DescriptorsTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(USBD_DescriptorsTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USBD_DescriptorsTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USBD_DescriptorsTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GetDeviceDescriptor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USBD_DescriptorsTypeDef),
            "::",
            stringify!(GetDeviceDescriptor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GetLangIDStrDescriptor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USBD_DescriptorsTypeDef),
            "::",
            stringify!(GetLangIDStrDescriptor)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).GetManufacturerStrDescriptor) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USBD_DescriptorsTypeDef),
            "::",
            stringify!(GetManufacturerStrDescriptor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GetProductStrDescriptor) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USBD_DescriptorsTypeDef),
            "::",
            stringify!(GetProductStrDescriptor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GetSerialStrDescriptor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USBD_DescriptorsTypeDef),
            "::",
            stringify!(GetSerialStrDescriptor)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).GetConfigurationStrDescriptor) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USBD_DescriptorsTypeDef),
            "::",
            stringify!(GetConfigurationStrDescriptor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GetInterfaceStrDescriptor) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USBD_DescriptorsTypeDef),
            "::",
            stringify!(GetInterfaceStrDescriptor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GetBOSDescriptor) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(USBD_DescriptorsTypeDef),
            "::",
            stringify!(GetBOSDescriptor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USBD_EndpointTypeDef {
    pub status: u32,
    pub total_length: u32,
    pub rem_length: u32,
    pub maxpacket: u32,
}
#[test]
fn bindgen_test_layout_USBD_EndpointTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<USBD_EndpointTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USBD_EndpointTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(USBD_EndpointTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USBD_EndpointTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USBD_EndpointTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USBD_EndpointTypeDef),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USBD_EndpointTypeDef),
            "::",
            stringify!(total_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USBD_EndpointTypeDef),
            "::",
            stringify!(rem_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxpacket) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USBD_EndpointTypeDef),
            "::",
            stringify!(maxpacket)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _USBD_HandleTypeDef {
    pub id: u8,
    pub dev_config: u32,
    pub dev_default_config: u32,
    pub dev_config_status: u32,
    pub dev_speed: USBD_SpeedTypeDef,
    pub ep_in: [USBD_EndpointTypeDef; 6usize],
    pub ep_out: [USBD_EndpointTypeDef; 6usize],
    pub ep0_state: u32,
    pub ep0_data_len: u32,
    pub dev_state: u8,
    pub dev_old_state: u8,
    pub dev_address: u8,
    pub dev_connection_status: u8,
    pub dev_test_mode: u8,
    pub dev_remote_wakeup: u32,
    pub request: USBD_SetupReqTypedef,
    pub pDesc: *mut USBD_DescriptorsTypeDef,
    pub interfacesClass: [_USBD_HandleTypeDef__bindgen_ty_1; 3usize],
    pub pUserData: *mut ::core::ffi::c_void,
    pub pData: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _USBD_HandleTypeDef__bindgen_ty_1 {
    pub pClass: *mut USBD_ClassTypeDef,
    pub pClassData: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout__USBD_HandleTypeDef__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_USBD_HandleTypeDef__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_USBD_HandleTypeDef__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_USBD_HandleTypeDef__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_USBD_HandleTypeDef__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_USBD_HandleTypeDef__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pClass) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef__bindgen_ty_1),
            "::",
            stringify!(pClass)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pClassData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef__bindgen_ty_1),
            "::",
            stringify!(pClassData)
        )
    );
}
impl Default for _USBD_HandleTypeDef__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__USBD_HandleTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<_USBD_HandleTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_USBD_HandleTypeDef>(),
        276usize,
        concat!("Size of: ", stringify!(_USBD_HandleTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<_USBD_HandleTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(_USBD_HandleTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_config) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(dev_config)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_default_config) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(dev_default_config)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_config_status) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(dev_config_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_speed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(dev_speed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_in) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(ep_in)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_out) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(ep_out)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep0_state) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(ep0_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep0_data_len) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(ep0_data_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_state) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(dev_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_old_state) as usize - ptr as usize },
        221usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(dev_old_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_address) as usize - ptr as usize },
        222usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(dev_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_connection_status) as usize - ptr as usize },
        223usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(dev_connection_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_test_mode) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(dev_test_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_remote_wakeup) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(dev_remote_wakeup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pDesc) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(pDesc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interfacesClass) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(interfacesClass)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(pUserData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pData) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_USBD_HandleTypeDef),
            "::",
            stringify!(pData)
        )
    );
}
impl Default for _USBD_HandleTypeDef {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type USBD_HandleTypeDef = _USBD_HandleTypeDef;
pub type io_send_t = ::core::option::Option<
    unsafe extern "C" fn(buffer: *mut ::core::ffi::c_uchar, length: ::core::ffi::c_ushort),
>;
pub type io_recv_t = ::core::option::Option<
    unsafe extern "C" fn(
        buffer: *mut ::core::ffi::c_uchar,
        maxlenth: ::core::ffi::c_ushort,
    ) -> ::core::ffi::c_ushort,
>;
pub const IO_USB_APDU_RESET: io_usb_hid_receive_status_e = 0;
pub const IO_USB_APDU_MORE_DATA: io_usb_hid_receive_status_e = 1;
pub const IO_USB_APDU_RECEIVED: io_usb_hid_receive_status_e = 2;
pub type io_usb_hid_receive_status_e = ::core::ffi::c_uchar;
pub use self::io_usb_hid_receive_status_e as io_usb_hid_receive_status_t;
extern "C" {
    pub static mut G_io_usb_hid_total_length: ::core::ffi::c_uint;
}
extern "C" {
    pub fn io_usb_hid_init();
}
extern "C" {
    pub fn io_usb_hid_receive(
        sndfct: io_send_t,
        buffer: *mut ::core::ffi::c_uchar,
        l: ::core::ffi::c_ushort,
        apdu_buffer: *mut apdu_buffer_t,
    ) -> io_usb_hid_receive_status_t;
}
extern "C" {
    pub fn io_usb_hid_sent(sndfct: io_send_t);
}
extern "C" {
    pub fn io_usb_hid_send(
        sndfct: io_send_t,
        sndlength: ::core::ffi::c_ushort,
        apdu_buffer: *mut ::core::ffi::c_uchar,
    );
}
extern "C" {
    pub fn LEDGER_BLE_init();
}
extern "C" {
    pub fn LEDGER_BLE_send(packet: *const u8, packet_length: u16);
}
extern "C" {
    pub fn LEDGER_BLE_receive(spi_buffer: *const u8);
}
extern "C" {
    pub fn LEDGER_BLE_set_recv_buffer(buffer: *mut u8, buffer_length: u16);
}
extern "C" {
    pub fn LEDGER_BLE_enable_advertising(enable: u8);
}
extern "C" {
    pub fn LEDGER_BLE_reset_pairings();
}
